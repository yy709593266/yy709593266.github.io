<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[JavaScript读书笔记(二)]]></title>
      <url>http://yy709593266.github.io/blog/2016/07/08/2016-07-08/</url>
      <content type="html"><![CDATA[<p>《JavaScript高级程序设计》第四章-变量、作用域和内存问题<br><a id="more"></a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript读书笔记(一)]]></title>
      <url>http://yy709593266.github.io/blog/2016/07/08/2016-07-01/</url>
      <content type="html"><![CDATA[<p>《JavaScript高级程序设计》第三章-基本概念<br><a id="more"></a></p>
<h3 id="延迟脚本defer和异步脚本aysnc"><a href="#延迟脚本defer和异步脚本aysnc" class="headerlink" title="延迟脚本defer和异步脚本aysnc"></a>延迟脚本defer和异步脚本aysnc</h3><p>按照惯例，所有<code>&lt;script&gt;</code>元素都应该在页面的<code>&lt;head&gt;</code>元素中。但是，这种做法，意味着必须等到全部JavaScript代码都被下载、解析和执行完成以后，才能开始呈现页面的内容。如果某个页面需要很多JavaScript代码，这种做法就会导致浏览器在呈现页面时出现明显的延迟，延迟期间的浏览器窗口中显示是空白的。为了避免这个问题，现在Web应用程序一般都把全部JavaScript引用放在<code>&lt;body&gt;</code>元素中所有内容的最后。现在，script可以通过添加<code>async</code>或<code>defer</code>属性来让脚本不必同步执行，这两个属性都不会暂停HTML解析就立刻被下载。</p>
<h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;script defer src=&quot;js/index1.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">	&lt;script defer src=&quot;js/index2.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	//code</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>defer脚本是按照加载script脚本文件的顺序执行脚本的。</p>
<h4 id="aysnc"><a href="#aysnc" class="headerlink" title="aysnc"></a>aysnc</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;script aysnc src=&quot;js/index1.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">	&lt;script aysnc src=&quot;js/index2.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	//code</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>aysnc脚本在script文件下载完成之后就立即执行，这意味着多个aysnc脚本很可能不会按其在页面中的出现顺序执行</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>defer和aysnc在网络下载这块是一样的，它们都是异步的(相对于HTML解析)，它们的差别在于脚本下载完之后何时执行，显然defer是最接近我们对于应用脚本加载和执行的要求的。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>1、使用<code>var</code>操作符定义的变量将成为定义该变量的作用域中的局部变量。也就是说，如果在函数中使用<code>var</code>定义一个变量，那么这个变量在函数退出后就会被销毁。<br>2、不使用<code>var</code>操作符定义的变量将成为全局变量。即在函数内不使用<code>var</code>操作符定义的变量，在函数外部可以被访问到。</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h4><p>typeof操作符用来检测给定变量的数据类型。<br>注：<code>typeof null</code>会返回<code>object</code>，因为特殊值null被认为是一个空的对象引用。</p>
<h4 id="Undefined类型"><a href="#Undefined类型" class="headerlink" title="Undefined类型"></a>Undefined类型</h4><p>Undefined类型值只有一个，即undefined。在使用操作符var定义变量但未对其加以初始化时，这个变量的值就是undefined，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var message;</span><br><span class="line">alert(message);//undefined</span><br></pre></td></tr></table></figure></p>
<p>注：对未初始化的变量使用typeof操作符运算返回undefined值，而对未声明的变量执行typeof操作符同样也会返回undefined值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var message;</span><br><span class="line">alert(typeof massage); //undefined</span><br><span class="line">alert(typeof age);     //undefined</span><br></pre></td></tr></table></figure></p>
<h4 id="Null类型"><a href="#Null类型" class="headerlink" title="Null类型"></a>Null类型</h4><p>Null类型值也只有一个，即null。null值表示一个空对象指针，所以使用typeof操作符检测null值时会返回<code>object</code>。一般在定义一个准备用来放置对象的变量时，初始化应该将其值设置为null，这样不仅可以体现null作为空对象指针的惯例，而且也有助于进一步区分null和undefined。</p>
<h4 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h4><p>1、Boolean类型值有两个字面量:true和false，作为特殊值书写时不用加引号<br>2、Boolean类型值区分大小写</p>
<h4 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h4><h5 id="浮点数值"><a href="#浮点数值" class="headerlink" title="浮点数值"></a>浮点数值</h5><p>JavaScript只有一种数字类型Number，而在JavaScript中所有的数字都是以IEEE-754标准格式表示的。浮点数的精度问题不是JavaScript特有的。浮点数值的最高精度是17位小数，进行算术计算时精度有限，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = 0.1;</span><br><span class="line">var b = 0.2;</span><br><span class="line">if (a + b == 0.3)&#123;  // false</span><br><span class="line">	console.log(&apos;true&apos;);</span><br><span class="line">&#125; else&#123;</span><br><span class="line">	console.log(&apos;false&apos;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里结果不是0.3，而是0.300000000000000004。所以，永远不要测试某个特定的浮点数值。<br>那么，如何避免这种非bug的问题呢？可以在判断运算结果前先对结果进行精度的缩小，精度缩小的过程就会自动四舍五入，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = 0.1;</span><br><span class="line">var b = 0.2;</span><br><span class="line">if ((a + b).toFixed(1) == 0.3)&#123;  // true</span><br><span class="line">	console.log(&apos;true&apos;);</span><br><span class="line">&#125; else&#123;</span><br><span class="line">	console.log(&apos;false&apos;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里对结果进行保留一位小数的运算，得到的结果就是0.3，返回的就是true了(一般可以将保留小数点设置为10)。</p>
<h5 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h5><p>NaN(Not a Number)是一个特殊值，表示一个本来要返回数值的操作数未返回数值(不会报错)，例如任何数值除以0会返回NaN(注:其他编程语言中会报错)。但是每个NaN是不相等的，即判断<code>(NaN == NaN)</code>会返回<code>false</code>。isNaN()方法用来判断给定值是否是NaN。</p>
<h5 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h5><p>1、Number()<br>Number()函数的转换规则如下</p>
<ul>
<li>Boolean值转换成1或0</li>
<li>null转换成0</li>
<li>undefined转换成NaN</li>
<li>如果是只包含数字的字符串，转换成十进制数值，前导0会忽略</li>
<li>如果是浮点数的字符串，转换成浮点数</li>
<li>如果字符串包含有效的十六进制格式，转换成相同大小的十进制数</li>
<li>空字符串转换成0</li>
<li>如果字符串包含除上述其他格式，转换成NaN<br>Number()函数在转换字符串时比较复杂而且不够合理，不是很常用(一般用parseInt()函数)。且Number()函数和一元加操作符的操作相同。<br>2、parseInt()<br>parseInt()函数在转换字符串时，会忽略字符串前面的空格，直到找到第一个非空格字符，如果第一个字符不是数字字符或者负号，parseInt()就会返回NaN，即parseInt()函数会将空字符串解析成NaN(注：Number()函数会将空字符解析成0)。如果第一个字符是数值，会继续解析第二个字符，直到解析完所有后续字符遇到非数字字符。当然，parseInt()是能够识别出八进制(<code>0</code>开头)和十六进制(<code>0x</code>开头)是数值的，一般为了避免错误的解析，建议在使用parseInt()函数时都明确加上第二个参数来指定基数，例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var num = parseInt(&quot;0xAF&quot;, 16);	//175</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>3、parseFloat()<br>parseFloat()函数也是从第一个字符开始解析每个字符，一直到字符串结尾，或者直到遇到一个无效的浮点数字字符为止，例如，当有两个小数点时，第一个小数点有效，第二个小数点以及后面的字符都会被忽略；parseFloat()函数始终会忽略前导的<code>0</code>；parseFloat()只解析十进制值，没有第二个参数，十六进制格式字符串始终会被转换成<code>0</code>。</p>
<h4 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h4><h5 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h5><p>反斜杠用来在文本字符串中插入省略号、换行符、引号和其他特殊字符。JavaScript的其余<em><a href="http://www.w3school.com.cn/js/js_special_characters.asp" target="_blank" rel="external">转义字符</a></em>都可以使用反斜杠来添加。</p>
<h5 id="转换成字符串"><a href="#转换成字符串" class="headerlink" title="转换成字符串"></a>转换成字符串</h5><p>1、toString()方法<br>toString()方法是几乎所有值都有的方法(除了null和undefined值)，不传递参数时默认以十进制格式返回数值的字符串表示，可以通过传递参数来指定数值的基数，来转换成指定基数下数值的字符串形式，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var num = 10;</span><br><span class="line">console.log(num.toString());	//&quot;10&quot;</span><br><span class="line">console.log(num.toString(2));	//&quot;1010&quot;</span><br><span class="line">console.log(num.toString(8));	//&quot;12&quot;</span><br><span class="line">console.log(num.toString(16));	//&quot;a&quot;</span><br></pre></td></tr></table></figure></p>
<p>2、String()方法<br>上面提到过，null和undefined值是没有toString()方法的，现在可以使用String()方法，这个函数能够将任何类型的值转换成字符串。String()遵循的转换规则如下：</p>
<ul>
<li>如果检测值有toString()方法，就会调用该方法返回相应结果</li>
<li>如果检测值是null，则返回字符串<code>&quot;null&quot;</code></li>
<li>如果检测值是undefined，则返回字符串<code>&quot;undefined&quot;</code></li>
</ul>
<p>另：数值转换成字符串，可以使用一元加操作符将该数值和空字符串<code>&quot;&quot;</code>相加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var lang = 123;</span><br><span class="line">console.log(lang);	//123</span><br><span class="line">lang = lang + &quot;&quot;;</span><br><span class="line">console.log(lang);	//&quot;123&quot;</span><br></pre></td></tr></table></figure></p>
<p>3、String对象方法<br>字符串是JavaScript的一种基本的数据类型，String类定义了大量<em><a href="http://www.w3school.com.cn/jsref/jsref_obj_string.asp" target="_blank" rel="external">操作字符串的方法</a></em>。<strong>需要注意的是，JavaScript的字符串是不可变的，String类定义的方法都不能改变原字符串的内容，像<code>String.toUpperCase()</code>这样的方法，返回的是全新的字符串，而不是修改原始字符串</strong>。<br>下面是一些常用或容易弄错的几种String方法举例：</p>
<ul>
<li><p>String对象中正则表达式方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// match()方法类似indexOf()方法，但是它返回指定的值，而不是字符串的位置</span><br><span class="line">var str = &quot;Hello world! Hello world!&quot;;</span><br><span class="line">console.log(str.match(&quot;world&quot;));	//world</span><br><span class="line">console.log(str.match(&quot;World&quot;));	//null</span><br><span class="line"></span><br><span class="line">// replace()方法用于替换字符串或一个与正则表达式匹配的子串</span><br><span class="line">console.log(str.replace(/world/, &quot;node&quot;));	//&quot;Hello node! Hello world&quot;</span><br><span class="line">console.log(str.replace(/world/g, &quot;node&quot;));	//&quot;Hello node! Hello node&quot;--全局查找</span><br><span class="line"></span><br><span class="line">// search()方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串</span><br><span class="line">console.log(str.search(/world/));	//6</span><br><span class="line">console.log(str.search(/World/));	//-1</span><br><span class="line">console.log(str.search(/World/i));	//6--忽略大小写</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他常用方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// slice()提取字符串段</span><br><span class="line">var str = &quot;Hello javascript world!&quot;;</span><br><span class="line">console.log(str.slice(6));				//javascript world!</span><br><span class="line">console.log(str.slice(6, 11));			//javas</span><br><span class="line">console.log(str.slice(-1));				//!</span><br><span class="line">console.log(str.slice(-3));				//ld!</span><br><span class="line"></span><br><span class="line">// split()方法用于把一个字符串分割成字符串数组</span><br><span class="line">// join()是数组的方法，用于将数组值组合生成字符串</span><br><span class="line">console.log(str.split(&quot; &quot;));			//[&quot;Hello&quot;, &quot;javascript&quot;, &quot;world!&quot;]</span><br><span class="line">console.log(str.split(&quot;&quot;));				//[&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot; &quot;, &quot;j&quot;, &quot;a&quot;, &quot;v&quot;, &quot;a&quot;, &quot;s&quot;, &quot;c&quot;, &quot;r&quot;, &quot;i&quot;, &quot;p&quot;, &quot;t&quot;, &quot; &quot;, &quot;w&quot;, &quot;o&quot;, &quot;r&quot;, &quot;l&quot;, &quot;d&quot;, &quot;!&quot;]</span><br><span class="line">console.log(str.split(&quot; &quot;, 2));			//[&quot;Hello&quot;, &quot;javascript&quot;]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h4><p><code>Object</code>对象分两种语法，一种是充当<em>构造函数</em>，结合<code>new</code>关键字创建一个<code>Object</code>对象，根据传入的参数返回一个对应类型的对象；另外一种是充当<em>普通函数</em>，不使用<code>new</code>关键字，两种语法有什么差呢？看一个栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Person(age)&#123;</span><br><span class="line">	this.age = age;</span><br><span class="line">	this.sex = &quot;male&quot;;</span><br><span class="line">&#125;</span><br><span class="line">person1 = Person(22);	//undefined</span><br></pre></td></tr></table></figure></p>
<p>这是当做普通函数执行，没有使用<code>new</code>关键字，person1返回值是undefined。因为Person()这个函数执行没有返回值，如果给它一个返回值，执行完以后就会有值输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person(age)&#123;</span><br><span class="line">	this.age = age;</span><br><span class="line">	this.sex = &quot;male&quot;;</span><br><span class="line">	return this.age;</span><br><span class="line">&#125;</span><br><span class="line">person1 = Person(22);	//22</span><br></pre></td></tr></table></figure></p>
<p>此时，执行完以后返回值就是person1的值，即22。并且，<code>sex</code>属性和<code>age</code>属性加到了<code>window</code>对象上，<code>person1.age</code>和<code>person1.sex</code>是没有值滴。<br>如果是充当构造函数的话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Person(age)&#123;</span><br><span class="line">	this.age = age;</span><br><span class="line">	this.sex = &quot;male&quot;;</span><br><span class="line">&#125;</span><br><span class="line">person1 = new Person(22);	//Person &#123;age: 22, sex: &quot;male&quot;&#125;</span><br></pre></td></tr></table></figure></p>
<p>person1返回的是Person的一个实例，并且包含了<code>sex</code>属性和<code>age</code>属性，可以通过<code>person1.sex</code>或<code>person1.age</code>访问person1的属性值。<br>Object的每个实例都具有下列属性和方法：</p>
<ul>
<li><code>constructor</code>：保存用于创建当前对象的函数，上个栗子中person1的constructor就是<code>function Person(){}</code></li>
<li><code>hasOwnProperty(propertyName)</code>：用于检查给定的属性在当前对象实例中(而非原型中)是否存在。</li>
<li><code>isPropertyOf(object)</code>：用于检查传入的对象是否是另一个对象的原型(后面原型和原型链中使用)</li>
<li><code>propertyIsEnumerable(propertyName)</code>：用于检查给定的属性是否能够使用<code>for-in</code>语句来枚举</li>
<li><code>toLocaleString()</code>：返回对象的字符串表示，该字符串与执行环境的地区对应，上个栗子中<code>person1.toLocaleString()</code>返回值是<code>&quot;[object Object]&quot;</code></li>
<li><code>toString()</code>：返回对象的字符串表示，类似<code>toLocaleString()</code></li>
<li><code>valueOf()</code>：返回对象的字符串、数值或布尔值表示，通常与<code>toString()</code>方法的返回值相同</li>
</ul>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>JavaScript中操作符包括一元操作符(<code>++</code>、<code>--</code>、<code>+</code>、<code>-</code>)，位操作符，布尔操作符(<code>!</code>、<code>&amp;&amp;</code>、<code>||</code>)，乘性操作符(<code>*</code>、<code>/</code>、<code>%</code>)，加性操作符(<code>+</code>、<code>-</code>)，关系操作符，相等操作符，条件操作符，赋值操作符，逗号操作符，这里对常用或易混淆的几种操作符进行陈述。</p>
<h4 id="一元递增和递减操作符-、"><a href="#一元递增和递减操作符-、" class="headerlink" title="一元递增和递减操作符(++、--)"></a>一元递增和递减操作符(<code>++</code>、<code>--</code>)</h4><p>递增和递减操作符各有两个版本：前置型和后置型。前置型递增和递减操作，变量的值都是在语句被求值以前改变的，后置型递增和递减操作，变量的值都是在语句被求值以后改变的，这个区别在某些情况下不是什么问题，但是在某些有包含了递增和递减的语句中有差别的，再举一个栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 无影响</span><br><span class="line">var age1 = 1;</span><br><span class="line">age1++;			//2</span><br><span class="line"></span><br><span class="line">var age2 = 1;</span><br><span class="line">++age2;			//2</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 有影响</span><br><span class="line">var age1 = 5;</span><br><span class="line">var age2 = age1++ + 5;</span><br><span class="line">console.log(age1);		//6</span><br><span class="line">console.log(age2);		//10</span><br><span class="line"></span><br><span class="line">var age3 = 5;</span><br><span class="line">var age4 = ++age3 + 5;</span><br><span class="line">console.log(age3);		//6</span><br><span class="line">console.log(age4);		//11</span><br></pre></td></tr></table></figure>
<p>从上面栗子中可以看出来，前置型递增(或递减)会在执行语句之前就改变自身的值，即递增1，然后再计算语句结果，即11，而后置型则会先执行语句以后再自身递增，所以结果自身都是递增1了的，但是得到的语句计算结果不一样。</p>
<h4 id="一元加减操作符-、"><a href="#一元加减操作符-、" class="headerlink" title="一元加减操作符(+、-)"></a>一元加减操作符(<code>+</code>、<code>-</code>)</h4><p>对于数值来说，一元加操作符不会产生任何影响，但是对于非数值前面加一个加操作符跟使用Number()函数结果是一样的。一元减运算符主要就是表示负数，对数值应用该操作符该值会变成负数，而对于非数值型值应用一元减操作符会先遵循一元加操作符相同的规则，最后再将值转换成负数。</p>
<h4 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h4><p>JavaScript的位操作符很少被用到，因为很多人不会用，虽然有些人还是会用的，但是涉及到代码的可读性，位运算往往受到批判，影响代码的可读性，当然这还是因为很多人不会用，所以这里就不详解位运算符了，就简单的列举一下。位操作符用于在最基本的层次上，按内存中表示数值的位来操作数值的，负数使用的是二进制补码的方式来存储的，相关运算符有：按位非<code>~</code>、按位与<code>&amp;</code>、按位或<code>|</code>、按位异或<code>^</code>、左移<code>&lt;&lt;</code>、有符号右移<code>&gt;&gt;</code>、无符号右移<code>&gt;&gt;&gt;</code>。<br>注：这些运算都是位运算，都是需要先转化为二进制数然后再运算的。</p>
<h4 id="布尔操作符-、-amp-amp-、"><a href="#布尔操作符-、-amp-amp-、" class="headerlink" title="布尔操作符(!、&amp;&amp;、||)"></a>布尔操作符(<code>!</code>、<code>&amp;&amp;</code>、<code>||</code>)</h4><p>逻辑与(<code>&amp;&amp;</code>)和逻辑或(<code>||</code>)操作都属于<strong>短路</strong>操作，即如果第一个操作数能够决定结果，就不会再对第二个操作数进行求值。</p>
<h4 id="乘性操作符-、-、"><a href="#乘性操作符-、-、" class="headerlink" title="乘性操作符(*、/、%)"></a>乘性操作符(<code>*</code>、<code>/</code>、<code>%</code>)</h4><p>乘法(<code>*</code>)、除法(<code>/</code>)、求模(求余数<code>%</code>)操作，如果有一个操作数不是数值，则在后台调用Number()将其转换成数值，然后再应用相应的操作符。</p>
<h4 id="加性操作符-、"><a href="#加性操作符-、" class="headerlink" title="加性操作符(+、-)"></a>加性操作符(<code>+</code>、<code>-</code>)</h4><p>加性操作符在后台转换不同的数据类型，相应的转换规则稍微有点复杂。</p>
<h5 id="加法"><a href="#加法" class="headerlink" title="加法(+)"></a>加法(<code>+</code>)</h5><ul>
<li>如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来</li>
<li>如果只有一个是字符串，则将另一个转换成字符串再拼接起来<code>var lang = 5+&#39;5&#39;</code>，这里<code>lang = &#39;55&#39;</code></li>
<li>如果有一个是对象、数值或布尔值，则调用它们的<code>toString()</code>方法取得相应的字符串值，再进行运算，对于<code>undefined</code>和<code>null</code>，调用<code>String()</code>函数取得字符串<code>undefined</code>和<code>null</code></li>
</ul>
<h5 id="减法"><a href="#减法" class="headerlink" title="减法(-)"></a>减法(<code>-</code>)</h5><ul>
<li>如果有一个是字符串、布尔值、null或undefined，则先在后台调用Number()函数将其转换成数值，然后再进行减法运算，如果转换结果是NaN，则减法结果就是NaN</li>
<li>如果有一个是对象，则调用对象的valueOf()方法获取表示该对象的数值，如果得到数值是NaN，则减法结果就是NaN，如果对象没有valueOf()方法，则调用其toString()方法将获得的字符串转换成数值。<br>必须举几个栗子看看：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var num1 = 5 - true;		//4</span><br><span class="line">var num2 = NaN - 1;			//NaN</span><br><span class="line">var num3 = 5 - &quot;&quot;;			//5</span><br><span class="line">var num4 = 5 - &quot;2&quot;;			//3</span><br><span class="line">var num5 = 5 - null;		//5</span><br><span class="line">var num6 = 5 - undefined;	//NaN</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注：Number()函数将null转换成0，undefined转换成NaN</p>
<h4 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h4><p>关系操作符包括<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code>，返回布尔值，运算规则如下：</p>
<ul>
<li>如果都是数值，比较大小即可</li>
<li>如果两个数都是字符串，则比较两个字符串对应的字符编码值(对应位置上的字符比较)</li>
<li>如果一个是数值，则将另一个转换成一个数值，再比较</li>
<li>如果一个是对象，则调用对象的valueOf()方法，得到结果，再比较，如果对象没有valueOf()方法，就调用对象的toString()方法，再比较</li>
<li>如果一个是布尔值，先转换成1或0再比较<br>看几个栗子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;a&quot; &gt; &quot;b&quot;;		//false</span><br><span class="line">&quot;a&quot; &gt; &quot;B&quot;;		//true,因为a的字符编码是97，B的字符编码是66</span><br><span class="line">&quot;23&quot; &gt; &quot;3&quot;;		//false,这是属于两个字符串比较的情况，2的字符编码小于3的字符编码</span><br><span class="line">&quot;23&quot; &gt; 3;		//true,这属于一个是数值的情况，另一个会转换成数值然后再比较</span><br><span class="line">&quot;a&quot; &lt; 3;		//false,这也是属于一个数值的情况，另一个应该转换成数值，但是a转换不了数值，就是NaN，而任意值和NaN比较都返回false</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h4><h5 id="相等和不相等-、"><a href="#相等和不相等-、" class="headerlink" title="相等和不相等(==、!=)"></a>相等和不相等(<code>==</code>、<code>!=</code>)</h5><p>相等和不相等操作符会先转换操作符，然后再比较，转换规则如下：</p>
<ul>
<li>如果操作数是布尔值，转换成1或0</li>
<li>如果一个是字符串一个是数值，先将字符串转换成数值再比较</li>
<li>如果一个是对象，一个不是，调用对象的valueOf()方法，再比较<br>相等和不相等操作符的比较也会有些既定的规则：</li>
<li>null和undefined相等的</li>
<li>比较相等性之前，不能讲null和undefined转换成其他任何值，所以<code>null == 0</code>和<code>undefined == 0</code>都返回false</li>
<li>NaN和其他值比较都是不相等的，包括NaN</li>
<li>如果两个都是对象，如果都指向同一个对象就相等</li>
</ul>
<h5 id="全等和不全等-、"><a href="#全等和不全等-、" class="headerlink" title="全等和不全等(===、!==)"></a>全等和不全等(<code>===</code>、<code>!==</code>)</h5><p>全等和不全等不对操作数进行转换，所以比较值且比较类型，所以<code>null==undefined</code>，但是<code>null!==undefined</code></p>
<h4 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h4><p>看一个栗子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var max = (num1 &gt; num2) ? num1 : num2;</span><br></pre></td></tr></table></figure></p>
<h4 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h4><p>这里说一个逗号运算符的赋值的栗子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var num = (1, 2, 3, 4);		//num值为4</span><br></pre></td></tr></table></figure></p>
<p>逗号赋值总会返回表达式中的最后一项</p>
<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>JavaScript语句有：if语句，do-while语句，while语句，for语句、for-in语句</p>
<h4 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h4><p>for循环的变量初始化表达式，也可以不使用<code>var</code>关键字，该变量的初始化可以在外部执行，因为JavaScript不存在块级作用域，所以很多时候我们都会在外面定义循环长度<code>var len = xxx; var i;</code>，然后再for循环表达式中直接写<code>(i = 0; i &lt; len; i++)</code></p>
<h4 id="for-in语句"><a href="#for-in语句" class="headerlink" title="for-in语句"></a>for-in语句</h4><p>for-in语句可以用来枚举对象的属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var key = &#123;</span><br><span class="line">    age: 23,</span><br><span class="line">    width: 70,</span><br><span class="line">    height: 89,</span><br><span class="line">    say: function()&#123;</span><br><span class="line">        alert(&apos;hello&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">for(var i in key)&#123;		//age,width,height,say</span><br><span class="line">    console.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码，每次执行循环时，都会将key对象存在的一个属性名赋值给变量name，一直持续到对象中所有属性都被枚举一遍为止。如果要迭代的对象的变量值是<code>null</code>或<code>undefined</code>的话呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var key = &#123;</span><br><span class="line">    age: 23,</span><br><span class="line">    width: 70,</span><br><span class="line">    height: 89,</span><br><span class="line">    say: function()&#123;</span><br><span class="line">        alert(&apos;hello&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">key = null;				//或key = undefined;</span><br><span class="line">for(var i in key)&#123;		//不执行循环体，无返回值</span><br><span class="line">    console.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>迭代对象是<code>null</code>或<code>undefined</code>不会执行循环体，也就没有返回值。<br>如果不是对象的话呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var key = [1,2,3,4,5,9];</span><br><span class="line">for(var i in key)&#123;		//0,1,2,3,4,5</span><br><span class="line">	console.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="label语句"><a href="#label语句" class="headerlink" title="label语句"></a>label语句</h4><p>label语句用的很少(反正我从来没用过，也不知道啥时有用)，使用label语句可以在JavaScript中添加标签以便将来使用，可以和<code>break</code>或者<code>continue</code>联合使用，这里就看一个栗子了解一下吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var temp=0;  </span><br><span class="line">start:  </span><br><span class="line">for(var i=0; i&lt;5; i++) &#123;  </span><br><span class="line">    for(var m=0; m&lt;5; m++) &#123;  </span><br><span class="line">        if(m==1) &#123;  </span><br><span class="line">            break start;  </span><br><span class="line">        &#125;  </span><br><span class="line">        temp++;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">alert(temp);</span><br></pre></td></tr></table></figure></p>
<p>这里会弹出1，如果没有label语句，还是这个双for循环的话，应该弹出5。我理解的这个label语句应该就是获取第一次达到跳出循环要求的状态。</p>
<h4 id="break和continue语句"><a href="#break和continue语句" class="headerlink" title="break和continue语句"></a>break和continue语句</h4><p><code>break</code>语句会立即退出循环，<code>continue</code>语句是立刻退出本次循环，但是会继续执行下一次循环，直到不满足条件终止循环。<code>break</code>语句和<code>continue</code>语句和<code>label</code>语句联合使用一般发生在玄幻嵌套的情况下，如下面的栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var temp=0;  </span><br><span class="line">start:  </span><br><span class="line">for(var i=0; i&lt;10; i++) &#123;  </span><br><span class="line">    for(var m=0; m&lt;10; m++) &#123;  </span><br><span class="line">        if(i==5 &amp;&amp; m==5) &#123;  </span><br><span class="line">            break start;  </span><br><span class="line">        &#125;  </span><br><span class="line">        temp++;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">alert(temp);</span><br></pre></td></tr></table></figure></p>
<p>这里弹出值为55，如果么有<code>label</code>语句的话，弹出值应该为95，所以，<code>label</code>值截取了第一次达到<code>break</code>的结果就跳出了，否则应该是达到要求时只跳出里面的循环，外面的循环应该继续。如果换成<code>continue</code>语句，那么<code>label</code>+<code>continue</code>的语句结果是95，不加<code>label</code>的continue语句结果是99，即<code>label</code>语句跳出了一次内循环。</p>
<h4 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h4><p>with语句的作用是将代码的作用域设置到一个特定的对象中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">with(location)&#123;</span><br><span class="line">	var hostName = hostname;	// 将location对象的hostname属性值赋值给hostName变量</span><br><span class="line">	var url = href;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是大量使用with语句会导致性能下降，同时造成调试困难，所以不建议使用。</p>
<h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><p>每次写switch语句都不记得语法是楞个样子的，这里再写一遍：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">switch (expression) &#123;</span><br><span class="line">	case value1: statement1</span><br><span class="line">		break;</span><br><span class="line">	case value2: statement2</span><br><span class="line">		break;</span><br><span class="line">	case value3: statement3</span><br><span class="line">		break;</span><br><span class="line">	default: statementend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>break用来跳出循环，否则即使满足条件了还会继续向下执行，default用来匹配如果前面都不符合条件的话，就执行这个。switch语句内部比较值时使用的是全等操作符，不会发生类型转换，即字符串<code>&quot;10&quot;</code>不等于数值<code>10</code>。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>注意：函数中的<code>return</code>用来返回值，<code>return</code>语句执行完以后就会停止并立即退出，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function sum(num1, num2) &#123;</span><br><span class="line">	return num1 + num2;</span><br><span class="line">	alert(&apos;Hello World&apos;);		//这个永远都不会被执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，也可以<code>return</code>不带有任何返回值，即直接<code>return;</code>，这样函数执行完以后将返回<code>undefined</code>，同样后面的语句依然不会被执行。</p>
<h4 id="理解参数"><a href="#理解参数" class="headerlink" title="理解参数"></a>理解参数</h4><p>JavaScript函数命名的参数只提供便利，但不是必需的，因为它参数内部是用一个数组来表示的，函数体内可以通过arguments对象来访问参数数组，length属性确定传进来的参数个数，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">	alert(arguments.length);</span><br><span class="line">&#125;</span><br><span class="line">test(&quot;string&quot;, 45);		//2</span><br><span class="line">test();					//0</span><br><span class="line">test(11);				//1</span><br></pre></td></tr></table></figure></p>
<p>由于这种机制，一个函数可以根据传递进来不同的参数个数执行不同的statements。<br>关于arguments，它的值永远与对应命名参数的值保持同步，栗如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Add(num1, num2)&#123;</span><br><span class="line">	arguments[1] = 10;</span><br><span class="line">	console.log(arguments[0] + num2);</span><br><span class="line">&#125;</span><br><span class="line">Add(10, 20);			//20</span><br></pre></td></tr></table></figure></p>
<p>修改arguments[1]也就修改了num2，结果它们的值都会变成10，不过这不是说读取这两个值访问相同的内存空间哈，它们的内存空间是独立的，但是值会同步，而且是单向同步，即修改命名参数不会改变arguments中对应的值。如果调用时只传入了一个参数，那么num2的值就是undefined</p>
<h4 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h4><p>Java重载是可以为一个函数编写两个定义，只要这两个定义接受的参数类型和数量不同即可。JavaScript中没有重载，如果定义了两个相同名字的函数，则该名字只属于后定义的函数，即后定义的函数会覆盖前面的函数。理解函数的参数，我们可以通过检查传入函数中参数类型和数量作出不同的反应，这样来模仿重载的方法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从插件开发了解jQuery源码]]></title>
      <url>http://yy709593266.github.io/blog/2016/06/23/2016-06-23/</url>
      <content type="html"><![CDATA[<p>想要开发jQuery插件，首先必须了解并熟悉jQuery源码，了解它的整体架构以及方法的实现，这里主要对jQuery插件开发相关的方法并加上自己的理解来进行阐述jQuery源码相关知识，从而让你找到适合自己的方法去理解和开发一个jQuery插件。<a id="more"></a></p>
<h4 id="jQuery的总体架构"><a href="#jQuery的总体架构" class="headerlink" title="jQuery的总体架构"></a>jQuery的总体架构</h4><p>打开jQuery的源码，会发现这样的代码结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function (window, undefined) &#123;</span><br><span class="line">	// jquery code</span><br><span class="line">&#125;)(window)</span><br></pre></td></tr></table></figure></p>
<p>通过定义一个自调用的匿名函数，创建一个私有空间，该私有空间的变量和方法，不会破坏全局的命名空间。jQuery被应用在成千上万的JavaScript程序中，必须确保jQuery创建的变量不能和导入它的程序所使用的变量发生冲突。既然作用范围在这个匿名函数中，怎么被别人使用呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.jQuery = window.$ = jQuery</span><br></pre></td></tr></table></figure></p>
<p>这里让jQuery库中最重要的jQuery对象成为了window对象的一个属性，这样就可以在其他地方像使用window.document来使用jQuery对象了，而$是jQuery的同名对象</p>
<h4 id="构造jQuery对象"><a href="#构造jQuery对象" class="headerlink" title="构造jQuery对象"></a>构造jQuery对象</h4><p>jQuery对象不是通过new jQuery创建的，而是通过new jQuery.fn.init创建的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var jQuery = function(selector, context)&#123;</span><br><span class="line">	return new jQuery.fn.init(selector, context);</span><br><span class="line">&#125;</span><br><span class="line">jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">	init: function(selector, context)&#123;</span><br><span class="line">	//init的功能是对传进来的selector参数进行分析，进行各种不同的处理，然后生成jQuery对象</span><br><span class="line">	&#125;</span><br><span class="line">	//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>jQuery对象就是jQuery.fn.init对象，这样构造jQuery对象的方法，如果执行new jQuery()生成的jQuery对象会被抛弃，最后返回jQuery.fn.init对象，因此可以直接调用jQuery(selector, context)，没有必要使用new关键字。<br>关于new出来的init和直接return的init有什么区别呢？<br>如果是直接return的init的话<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var jQuery = function(selector, context) &#123;</span><br><span class="line">   return  jQuery.prototype.init();</span><br><span class="line">&#125;</span><br><span class="line">jQuery.prototype = &#123;</span><br><span class="line">    init:function()&#123;</span><br><span class="line">    	this.age = 10;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;,</span><br><span class="line">    name:function()&#123;</span><br><span class="line">    	console.log(&apos;name&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    age: 20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当执行jQuery()返回如下:<br><img src="http://7xvmm0.com1.z0.glb.clouddn.com/7A11.tmp.jpg" alt=""><br>jQuery()返回的是jQuery类的实例，init中的this其实也是指向jQuery类的实例。<br>如果是new出来的init的话<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var jQuery = function(selector, context) &#123;</span><br><span class="line">   return  new jQuery.prototype.init();</span><br><span class="line">&#125;</span><br><span class="line">jQuery.prototype = &#123;</span><br><span class="line">    init:function()&#123;</span><br><span class="line">    	this.age = 10</span><br><span class="line">        return this;</span><br><span class="line">    &#125;,</span><br><span class="line">    name:function()&#123;</span><br><span class="line">    	console.log(&apos;name&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    age: 20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行jQuery()返回如下：<br><img src="http://7xvmm0.com1.z0.glb.clouddn.com/5DEC.tmp.jpg" alt=""><br>此时抛出错误，无法找到这个方法，所以显然就是new出来的init和jQuery类的this已经分离了。那么init想要访问到jQuery类原型上的属性和方法的话，实现的关键就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">	init: function(selector, context)&#123;</span><br><span class="line">	//init的功能是对传进来的selector参数进行分析，进行各种不同的处理，然后生成jQuery对象</span><br><span class="line">	&#125;</span><br><span class="line">	//...</span><br><span class="line">&#125;</span><br><span class="line">jQuery.fn.init.prototype = jQuery.fn; </span><br><span class="line">// 通过原型传递解决，把jQuery原型传递给jQuery.prototype.init.prototype</span><br><span class="line">// 也就是jQuery的原型覆盖了init构造器的原型对象。</span><br></pre></td></tr></table></figure></p>
<p>先执行<code>jQuery.fn = jQuery.prototype</code>，再执行<code>jQuery.fn,init,prototype = jQuery.fn</code>，合并后的代码就是<code>jQuery.fn.init.prototype = jQuery.fn = jQuery.prototype</code>。所有挂载到jQuery.fn的方法，相当于挂载到了jQuery.prototype，即挂载到了jQuery函数上，但是最后都相当于挂载到了jQuery.fn.init.prototype，相当于挂载到了一开始的jQuery函数返回的对象上，即挂载到了我们最终使用的jQuery对象上（因为我们一开始创建的jQuery对象就是jQuery函数返回的对象）。<br>此时，执行jQuery()返回如下：<br><img src="http://7xvmm0.com1.z0.glb.clouddn.com/D013.tmp.jpg" alt=""><br>每个函数都<code>return this</code>的话，就可以实现链式调用了，因为调用完一个方法以后返回对象依旧可以调用该对象上的其他方法。</p>
<h4 id="jQuery插件接口"><a href="#jQuery插件接口" class="headerlink" title="jQuery插件接口"></a>jQuery插件接口</h4><p>方法jQuery.extend()和jQuery.fn.extend()常用于编写插件和处理函数的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jQuery.extend() 对jQuery本身的属性和方法进行了扩展</span><br><span class="line">//比如：$.ajax()、$.getJSON()方法等</span><br><span class="line">jQuery.fn.extend() 对jQuery.fn(即jQuery.prototype)的属性和方法进行了扩展</span><br><span class="line">//比如：$(ele).addClass()、$(ele).find()方法等</span><br></pre></td></tr></table></figure></p>
<p>从jQuery源码中可以看到，jQuery.extend()方法和jQuery.fn.extend()方法其实是同指向同一方法的不同引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jQuery.extend = jQuery.fn.jQuery = function () &#123;</span><br><span class="line">	// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这两个方法指向同一个函数，怎么会实现不同的功能呢，这就是this的力量。jQuery.extend时，this指的是jQuery；jQuery.fn.extend时，this指的是jQuery.fn即jQuery.prototype。<br>针对fn与jQuery其实是2个不同的对象：</p>
<ul>
<li>jQuery.extend调用的时候，this是指向jQuery对象的，所以这里扩展在jQuery上。把jQuery看成一个类的话，那么jQuery.extend就是在这个类上扩展了一个方法，直接$.functionname就可以直接用类来调用这个方法，即<em>给jQuery类本身添加方法</em>。</li>
<li>jQuery.fn.extend调用的时候，this指向fn对象，而jQuery.fn和jQuery.prototype指向同一对象，扩展fn就是扩展jQuery.prototype原型对象，就是类的实例化嘛，需要$(ele).functionname先实例化一个对象再来调用方法，即<em>给jQuery对象添加方法</em>。其实fn没有什么特别的意思，就只是jQuery.prototype的引用而已。</li>
</ul>
<h4 id="jQuery-extend的合并对象功能"><a href="#jQuery-extend的合并对象功能" class="headerlink" title="jQuery.extend的合并对象功能"></a>jQuery.extend的合并对象功能</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jQuery.extend([deep], target, object1, [objectN])</span><br><span class="line">// 合并对象到第一个对象</span><br></pre></td></tr></table></figure>
<p>第一种合并<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var object1 = &#123;</span><br><span class="line">	apple: 0,</span><br><span class="line">	banana: &#123;weight: 52, price: 100&#125;,</span><br><span class="line">	cherry: 97</span><br><span class="line">&#125;;</span><br><span class="line">var object2 = &#123;</span><br><span class="line">	banana: &#123;price: 200&#125;,</span><br><span class="line">	orange: 100</span><br><span class="line">&#125;;</span><br><span class="line">$.extend(object1, object2);</span><br><span class="line">// 将object1和object2合并到object1中了</span><br><span class="line">// object2值不变</span><br></pre></td></tr></table></figure></p>
<p>第二种合并<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var object1 = &#123;</span><br><span class="line">	apple: 0,</span><br><span class="line">	banana: &#123;weight: 52, price: 100&#125;,</span><br><span class="line">	cherry: 97</span><br><span class="line">&#125;;</span><br><span class="line">var object2 = &#123;</span><br><span class="line">	banana: &#123;price: 200&#125;,</span><br><span class="line">	orange: 100</span><br><span class="line">&#125;;</span><br><span class="line">object3 = $.extend(&#123;&#125;,object1, object2);</span><br><span class="line">// 将object1和object2合并到object3上了</span><br><span class="line">// object1和object2值均不变</span><br></pre></td></tr></table></figure></p>
<p>第三种–深度合并<br>深度合并和非深度合并的区别是，深度合并的对象中如果复杂属性值(比如数组、函数、json对象等)，合并以后，如果再修改合子并对象的属性值，合并结果对象的值不会改变<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;</span><br><span class="line">	a: &apos;a&apos;,</span><br><span class="line">	b: &apos;b&apos;</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = &#123;</span><br><span class="line">	c: &#123;cc: &apos;cc&apos;, ccc: &apos;ccc&apos;&#125;,</span><br><span class="line">	d: &apos;d&apos;</span><br><span class="line">&#125;;</span><br><span class="line">$.extend(true, obj1, obj2);</span><br><span class="line">// 合并以后obj1和obj2都合并到obj1上了</span><br><span class="line">obj2.c.cc = &apos;11&apos;;</span><br><span class="line">//现在改变合并子对象obj2的属性值，合并后的obj1的属性值不会改变的</span><br><span class="line">console.log(obj2.c.cc); // 11</span><br><span class="line">console.log(obj1.c.cc); // cc</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[前端开发规范]]></title>
      <url>http://yy709593266.github.io/blog/2016/06/17/2016-06-17/</url>
      <content type="html"><![CDATA[<p>为提高团队协作效率，便于后台人员添加功能及前端后期优化维护，特制订本文档。本文档如有不对或者不合适的地方请及时提出。<a id="more"></a></p>
<h3 id="HTML编码原则"><a href="#HTML编码原则" class="headerlink" title="HTML编码原则"></a>HTML编码原则</h3><h4 id="第一行统一使用HTML5标准"><a href="#第一行统一使用HTML5标准" class="headerlink" title="第一行统一使用HTML5标准"></a>第一行统一使用HTML5标准</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">  &lt;title&gt;my title&lt;/title&gt;</span><br><span class="line">  &lt;meta name=&quot;keywords&quot; content=&quot;xxxx, xxx, xxxxx&quot; /&gt;</span><br><span class="line">  &lt;meta name=&quot;description&quot; content=&quot;xxxxxxxxxxxxxxxxxxxx&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h4 id="语言类型"><a href="#语言类型" class="headerlink" title="语言类型"></a>语言类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 中文 --&gt;</span><br><span class="line">&lt;html lang=&quot;zh-Hans&quot;&gt;</span><br><span class="line">&lt;!-- 简体中文 --&gt;</span><br><span class="line">&lt;html lang=&quot;zh-cmn-Hans&quot;&gt;</span><br><span class="line">&lt;!-- 繁体中文 --&gt;</span><br><span class="line">&lt;html lang=&quot;zh-cmn-Hant&quot;&gt;</span><br><span class="line">&lt;!-- English --&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="meta的使用"><a href="#meta的使用" class="headerlink" title="meta的使用"></a>meta的使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt; // 优先使用最新版本的IE 和 Chrome 内核</span><br><span class="line">&lt;meta chartset=&quot;utf-8&quot;&gt; // 网页显示字符集</span><br><span class="line">&lt;meta name=&quot;description&quot; content=&quot;这里填您网站的简介&quot;&gt; // 网站简介</span><br><span class="line">&lt;meta name=&quot;keywords&quot; content=&quot;关键字1,关键字2,关键字3,...&quot;&gt; // 搜索关键字</span><br><span class="line">&lt;link href=&quot;style/style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt; // 网页的CSS规范 </span><br><span class="line">&lt;title&gt;这里是网页标题&lt;title&gt; // 网页标题</span><br></pre></td></tr></table></figure>
<h4 id="html标签"><a href="#html标签" class="headerlink" title="html标签"></a>html标签</h4><ul>
<li>自闭和标签无需闭合(例如：<code>img</code> <code>input</code> <code>br</code> <code>hr</code>等)</li>
<li>可选的闭合标签需闭合(例如：’li’ ‘body’)</li>
<li>尽量减少标签数量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;images/google.png&quot; alt=&quot;Google&quot;&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; name=&quot;title&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;Style&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;Guide&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="网页制作字体"><a href="#网页制作字体" class="headerlink" title="网页制作字体"></a>网页制作字体</h4><ul>
<li>在设定字体样式时对于文字字号样式和行间距样式必须使用CSS样式表</li>
<li>在网页中中文应首选使用宋体，英文和数字首选verdana和arial两种字体。一般使用中文宋体的9pt和11pt或12px和14.7px，黑体字或者宋体字加粗时，一般选用11pt和14.7px的字号比较合适</li>
<li>为了最大程度的发挥浏览器自动排版的功能，在一段完整的文字中请尽量不要使用<code>&lt;br&gt;</code>来人工干预分段</li>
<li>网页中的空白应该尽量使用<code>text-indent</code>、<code>padding</code>、<code>margin</code>等以及透明的gif图片来实现</li>
<li>行距建议用百分比来定义，常用的两个行距值为120%和150%</li>
</ul>
<h4 id="网页制作链接"><a href="#网页制作链接" class="headerlink" title="网页制作链接"></a>网页制作链接</h4><ul>
<li>在浏览器中，我们点击空链接时，它会自动将当前页面重置到首端，从而影响用户正常的阅读内容，我们用代码<code>javascript:void(null)</code>代替原来的<code>#</code>标记</li>
</ul>
<h4 id="html文件命名"><a href="#html文件命名" class="headerlink" title="html文件命名"></a>html文件命名</h4><ul>
<li>各子页命名的原则首先应该以栏目名的英文翻译取单一单词为名称。例如：<blockquote>
<p>关于我们 \aboutus<br>信息反馈 \feedback<br>产品 \product</p>
</blockquote>
</li>
</ul>
<h4 id="html所有标签、属性、值均使用小写字母，且属性的值前后使用双引号，属性之间使用一个英文空格隔开"><a href="#html所有标签、属性、值均使用小写字母，且属性的值前后使用双引号，属性之间使用一个英文空格隔开" class="headerlink" title="html所有标签、属性、值均使用小写字母，且属性的值前后使用双引号，属性之间使用一个英文空格隔开"></a>html所有标签、属性、值均使用小写字母，且属性的值前后使用双引号，属性之间使用一个英文空格隔开</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; value=&quot;info&quot;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="属性书写顺序"><a href="#属性书写顺序" class="headerlink" title="属性书写顺序"></a>属性书写顺序</h4><ul>
<li>id</li>
<li>class</li>
<li>name</li>
<li>data-xxx</li>
<li>src, for, type, href</li>
<li>aria-xxx, role<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;a id=&quot;...&quot; class=&quot;...&quot; data-modal=&quot;toggle&quot; href=&quot;###&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;input class=&quot;form-control&quot; type=&quot;text&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;...&quot; alt=&quot;...&quot;&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="布尔值属性"><a href="#布尔值属性" class="headerlink" title="布尔值属性"></a>布尔值属性</h4><p>HTML5 规范中 <code>disabled</code>、<code>checked</code>、<code>selected</code>等属性不用设置值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; disabled&gt;</span><br><span class="line"></span><br><span class="line">&lt;input type=&quot;checkbox&quot; value=&quot;1&quot; checked&gt;</span><br><span class="line"></span><br><span class="line">&lt;select&gt;</span><br><span class="line">  &lt;option value=&quot;1&quot; selected&gt;1&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="标签嵌套必须合理正确，严禁在行内元素内嵌使用块级元素标签"><a href="#标签嵌套必须合理正确，严禁在行内元素内嵌使用块级元素标签" class="headerlink" title="标签嵌套必须合理正确，严禁在行内元素内嵌使用块级元素标签"></a>标签嵌套必须合理正确，严禁在行内元素内嵌使用块级元素标签</h4><ul>
<li>常见的块级元素有 :div、p、table、td、tr、ul、ol、li、fieldset、legen、form、 blockquote、h1-h6、dl、dt、dd …</li>
<li>常见的行内元素有:span、a、strong、 b、em、i、s、u、site…<h5 id="常见错误示例："><a href="#常见错误示例：" class="headerlink" title="常见错误示例："></a>常见错误示例：</h5></li>
<li>a标签、span标签内嵌套包含div、p等标签</li>
<li>在li标签、dt、dd、标签内直接包含div、h1-h6等块级元素在某些浏览器下也会出现兼容性问题，谨慎使用。</li>
</ul>
<h4 id="合理规划文档结构，去除不必要的-lt-div-gt-标签"><a href="#合理规划文档结构，去除不必要的-lt-div-gt-标签" class="headerlink" title="合理规划文档结构，去除不必要的&lt;div&gt;标签"></a>合理规划文档结构，去除不必要的<code>&lt;div&gt;</code>标签</h4><h4 id="先分析布局，划分框架，然后规划结构，最后编写代码"><a href="#先分析布局，划分框架，然后规划结构，最后编写代码" class="headerlink" title="先分析布局，划分框架，然后规划结构，最后编写代码"></a>先分析布局，划分框架，然后规划结构，最后编写代码</h4><h4 id="html标签语义化"><a href="#html标签语义化" class="headerlink" title="html标签语义化"></a>html标签语义化</h4><p>常见标签语义</p>
<blockquote>
<p><code>&lt;p&gt;</code>：段落<br><code>&lt;h1&gt;</code> <code>&lt;h2&gt;</code> <code>&lt;h3&gt;</code> …：标题<br><code>&lt;ul&gt;</code>：无序列表<br><code>&lt;ol&gt;</code>：有序列表<br><code>&lt;blockquote&gt;</code>：大段引用<br><code>&lt;cite&gt;</code>：一般引用<br><code>&lt;b&gt;</code>：为样式加粗而加粗<br><code>&lt;strong&gt;</code>：为强调内容而加粗<br><code>&lt;i&gt;</code>：为样式倾斜而倾斜<br><code>&lt;em&gt;</code>：为强调内容而倾斜<br><code>code</code>：代码标识<br><code>abbr</code>：缩写</p>
</blockquote>
<h4 id="代码缩进规范"><a href="#代码缩进规范" class="headerlink" title="代码缩进规范"></a>代码缩进规范</h4><ul>
<li>html代码的层级缩进为一个tab</li>
<li>跨行标签的开始标签和结束标签必须上下对齐</li>
<li>值为空的元素定义应该单独占用一行</li>
</ul>
<h4 id="前景图片编码原则"><a href="#前景图片编码原则" class="headerlink" title="前景图片编码原则"></a>前景图片编码原则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img alt=&quot;图片说明&quot; src=&quot;logo_header.png&quot; /&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>img标签必须闭合</li>
<li>所有图片必须添加alt属性值</li>
<li>图片的名称分为头尾两部分，用下划线隔开，头部分表示此图片的大类性质。例如：广告、标志、菜单、按钮等</li>
<li>放置在页面顶部的广告、装饰图案等长方形的图片取名：banner</li>
<li>标志性的图片取名为：logo</li>
<li>在页面上位置不固定并且带有链接的小图片我们取名为button</li>
<li>在页面上某一个位置连续出现，性质相同的链接栏目的图片我们取名为：menu</li>
<li>装饰用的图片我们取名：pic</li>
<li>不带链接表示标题的图片取名：title</li>
<li>鼠标感应效果图片命名规范为”图片名+_on/off”。例如：menu_on.gif menu_off.gif</li>
</ul>
<h4 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h4><ul>
<li>使用<code>&lt;!----&gt;</code>的方式添加注释</li>
<li>html文档中对于单独的模块或者超过50行的超长代码块做注释</li>
</ul>
<h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><ul>
<li><code> </code> : &amp;nbsp</li>
<li>&lt; : &amp;lt</li>
<li>> : &amp;gt</li>
<li>￥ : &amp;yen</li>
<li>“ : &amp;quot</li>
<li>&amp; : &amp;amp</li>
<li>© : &amp;copy</li>
<li>® : &amp;reg</li>
<li>‘ : &amp;#39</li>
<li>™ : &amp;trade</li>
<li>× : &amp;times</li>
<li>÷ : &amp;divide</li>
</ul>
<h4 id="IE中HTML条件注释"><a href="#IE中HTML条件注释" class="headerlink" title="IE中HTML条件注释"></a>IE中HTML条件注释</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[if IE 6]&gt;  IE6  &lt;![endif]--&gt; </span><br><span class="line">&lt;!--[if IE 7]&gt;  IE7  &lt;![endif]--&gt; </span><br><span class="line">&lt;!--[if lt IE 8]&gt;  小于IE8  &lt;![endif]--&gt; </span><br><span class="line">&lt;!--[if lte IE 8]&gt;  小于等于IE8  &lt;![endif]--&gt; </span><br><span class="line">&lt;!--[if gt IE 6]&gt;  大于IE6  &lt;![endif]--&gt; </span><br><span class="line">&lt;!--[if gte IE 6]&gt;  大于等于IE6  &lt;![endif]--&gt; </span><br><span class="line">&lt;!--[if !IE]&gt;  除IE外都可识别  &lt;![endif]--&gt; </span><br><span class="line">&lt;!--[if IE]&gt; 所有的IE可识别 &lt;![endif]--&gt;</span><br></pre></td></tr></table></figure>
<h3 id="CSS编码原则"><a href="#CSS编码原则" class="headerlink" title="CSS编码原则"></a>CSS编码原则</h3><h4 id="外联方式"><a href="#外联方式" class="headerlink" title="外联方式"></a>外联方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;css/common.css&quot;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>原则上，不允许在html上直接写样式</li>
<li>内外联方式的类型声明<code>type=&quot;text/css&quot;</code>都可以省略</li>
<li>link和style标签都应该放在head中</li>
<li>禁止在css文件内部采用@import方式引入其他css文件</li>
<li>如遇修改线上css文件内引用的背景图，需要在相应url后添加版本号，如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background: url(images/sprite.png?v=20160616);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="id和class使用规范"><a href="#id和class使用规范" class="headerlink" title="id和class使用规范"></a>id和class使用规范</h4><ul>
<li>class应以功能或内容命名，不以表现形式命名</li>
<li>class和id单词字母小写，多个单词组成时，采用中划线<code>-</code>分隔</li>
<li>使用唯一的id作为JavaScript hook，同时避免创建无样式信息的class</li>
<li>id是唯一的并是父级的，class是可以重复的并是子级的，所以id仅使用在大的模块上，class可用在重复使用率高及字级中</li>
<li>规避class与id重名</li>
</ul>
<h4 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h4><ul>
<li>规则命名采用小写加中划线<code>-</code>的方式，不允许使用大写字母或下划线<code>_</code></li>
<li>命名推荐采用更简明有语义单词进行组合，应尽量避免使用中文拼音，尤其是首字母简拼</li>
<li>DOM一律不准使用<code>id</code>挂载css，且避免id和class重名</li>
<li>规则名称中不应该包含颜色(red/blue)、大小(width/height)等信息，应该使用其意义或功能命名，而不是样式显示结果</li>
<li>禁止类名中出现<code>ad</code>字样，防止被广告插件屏蔽</li>
<li>取父级元素id/class命名部分命名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;main&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;main_firstnav&quot;&gt;&lt;div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="书写规范"><a href="#书写规范" class="headerlink" title="书写规范"></a>书写规范</h4><ul>
<li><p>禁止直接为html的tag添加css样式，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div &#123;color: red;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>尽量避免使用<code>!important</code></p>
</li>
<li>如果可以，颜色尽量用三位字符表示</li>
<li>0后面不需要单位，0.8px可以略写成.8px</li>
<li><p>如果没有边框时，不要写成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border: 0;</span><br></pre></td></tr></table></figure>
<p>  应该写成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border: 0 none;</span><br></pre></td></tr></table></figure>
</li>
<li><p>background、font等可以缩写的属性，尽量使用缩写形式，合并margin、padding、border的值时，尽量使用缩写</p>
</li>
</ul>
<h4 id="规范属性书写顺序"><a href="#规范属性书写顺序" class="headerlink" title="规范属性书写顺序"></a>规范属性书写顺序</h4><ul>
<li>显示、位置属性(Positioning)<br>display, position, left, top, float, clear, list-style</li>
<li>自身属性(Box model)<br>width, height, margin, padding, border</li>
<li>背景、行高(Typographic)<br>background, line-height</li>
<li>文本属性(Visual)<br>color, font, text-decroration, text-align, white-space, vertical-align, word-wrap, word-break</li>
<li>其他(Other)<br>cursor, z-index, zoom, opacity</li>
<li>css3<br>transform, transition, animation, box-shadow, border-radius</li>
<li>hack<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">.declaration-order &#123;</span><br><span class="line">  /* Positioning */</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  z-index: 100;</span><br><span class="line"></span><br><span class="line">  /* Box model */</span><br><span class="line">  display: block;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  padding: 10px;</span><br><span class="line">  border: 1px solid #e5e5e5;</span><br><span class="line">  border-radius: 3px;</span><br><span class="line">  margin: 10px;</span><br><span class="line">  float: right;</span><br><span class="line">  overflow: hidden;</span><br><span class="line"></span><br><span class="line">  /* Typographic */</span><br><span class="line">  font: normal 13px &quot;Helvetica Neue&quot;, sans-serif;</span><br><span class="line">  line-height: 1.5;</span><br><span class="line">  text-align: center;</span><br><span class="line"></span><br><span class="line">  /* Visual */</span><br><span class="line">  background-color: #f5f5f5;</span><br><span class="line">  color: #fff;</span><br><span class="line">  opacity: .8;</span><br><span class="line"></span><br><span class="line">  /* Other */</span><br><span class="line">  cursor: pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="排版规范"><a href="#排版规范" class="headerlink" title="排版规范"></a>排版规范</h4><h5 id="单行书写"><a href="#单行书写" class="headerlink" title="单行书写"></a>单行书写</h5><ul>
<li>多个selector共用一个样式集时，多个selector之间作为分隔标识的逗号后需要一个空格</li>
<li>每一个规则的大括号<code>{</code>前后都添加一个空格</li>
<li>属性名与值得冒号前不加空格，冒号之后加空格</li>
<li>每一个属性值后必须添加分号，并且分号后空格<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selector, selector2, selector3 &#123; display: block; width: 100px; border: 1px solid #F00; &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="多行书写"><a href="#多行书写" class="headerlink" title="多行书写"></a>多行书写</h5><ul>
<li>多个selector共用一个样式集时，多个selector单独成行</li>
<li>每一个规则的大括号<code>{</code>前添加空格</li>
<li>属性名与值得冒号前不加空格，冒号之后加空格</li>
<li>每一个属性值后必须添加分号<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">selector,</span><br><span class="line">selector2,</span><br><span class="line">selector3 &#123;</span><br><span class="line">	dispaly: block;</span><br><span class="line">	width: 100px;</span><br><span class="line">	border: 1px solid #F00;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="链接的样式顺序"><a href="#链接的样式顺序" class="headerlink" title="链接的样式顺序"></a>链接的样式顺序</h4><p><code>a:link</code>-&gt;<code>a:visited</code>-&gt;<code>a:hover</code>-&gt;<code>a:active</code></p>
<h4 id="正确使用display属性"><a href="#正确使用display属性" class="headerlink" title="正确使用display属性"></a>正确使用<code>display</code>属性</h4><p><code>display</code>属性会影响页面的渲染，请合理使用</p>
<ul>
<li><code>display: inline</code>后不应该再使用 <code>width</code>、<code>height</code>、<code>margin</code>、<code>padding</code>以及<code>float</code>；</li>
<li><code>display: inline-block</code>后不应该再使用<code>float</code>；</li>
<li><code>display: block</code>后不应该再使用<code>vertical-align</code>；</li>
<li><code>display: table-*</code>后不应该再使用<code>margin</code>或者<code>float</code>；</li>
</ul>
<h4 id="不要使用-import"><a href="#不要使用-import" class="headerlink" title="不要使用@import"></a>不要使用<code>@import</code></h4><p>与<code>&lt;link&gt;</code>相比，<code>@import</code>要慢很多，不光增加额外的请求数，还会导致不可预料的问题，替代办法：</p>
<ul>
<li>使用多个元素；</li>
<li>通过Sass或Less类似的CSS预处理器将多个CSS文件编译为一个文件</li>
<li>其他CSS文件合并工具</li>
</ul>
<h4 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h4><p>将媒体查询放在尽可能相关规则的附近。不要将他们打包放在一个单一样式文件中或者放在文档底部。如果你把他们分开了，将来只会被大家遗忘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.element &#123; ... &#125;</span><br><span class="line">.element-avatar &#123; ... &#125;</span><br><span class="line">.element-selected &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">@media (max-width: 768px) &#123;</span><br><span class="line">  .element &#123; ...&#125;</span><br><span class="line">  .element-avatar &#123; ... &#125;</span><br><span class="line">  .element-selected &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li>在可以不使用引号的情况下尽量不使用引号</li>
<li>使用单引号，不建议使用双引号</li>
<li>开发阶段的css 文件（非单条样式集），为了能够对开发人员友好，不要求压缩为单行。发布生产的css 文件，外联文件或内联片段都需要压缩为单行，且删除注释与非属性值内空格。</li>
</ul>
<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><ul>
<li>选择器应该在满足功能的基础上尽量简洁，减少嵌套选择器的查询消耗</li>
<li><p>在保持代码解耦的前提下，尽量合并重复的样式，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h1&#123;color:red;&#125;</span><br><span class="line">p&#123;color:red;&#125;</span><br></pre></td></tr></table></figure>
<p>  应该写成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">color,p&#123;color:red&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>css背景图要使用sprite技术，可按照相关度（是否模块、页面等）进行合并，并存储为web所用格式。图片优先使用png8格式保存，并适当压缩体积。在存在透明通道的情况下可使用png24图片，在色值较多的情况下，可使用jpg格式保存</p>
</li>
<li><p>充分利用html自身属性及样式继承原理减少代码量。例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">	&lt;li&gt;这里是标题&lt;span&gt;2016-8-7&lt;/span&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<p>  中定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ul li&#123; position: relative; &#125;</span><br><span class="line">ul li span&#123;</span><br><span class="line">	position: absolute;</span><br><span class="line">	right: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>即可实现日期居右显示</p>
<h4 id="提升CSS选择器性能"><a href="#提升CSS选择器性能" class="headerlink" title="提升CSS选择器性能"></a>提升CSS选择器性能</h4><p>CSS 选择器对性能的影响源于浏览器匹配选择器和文档元素时所消耗的时间，所以优化选择器的原则是应尽量避免使用消耗更多匹配时间的选择器。而在这之前我们需要了解CSS选择器匹配的机制，如子选择器规则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#header &gt; a &#123;font-weight:blod;&#125;</span><br></pre></td></tr></table></figure></p>
<p>CSS选择器是从右到左进行规则匹配。了解这个机制后，例子中看似高效的选择器在实际中的匹配开销是很高的，浏览器必须遍历页面中所有的a元素并且确定其父元素的id是否为header。<br>如果把例子的子选择器改为后代选择器则会开销更多，在遍历页面中所有a元素后还需向其上级遍历直到根节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#header a &#123; font-weight: bold;&#125;</span><br></pre></td></tr></table></figure></p>
<p>理解了CSS选择器从右到左匹配的机制后，明白只要当前选择符的左边还有其他选择符，样式系统就会继续向左移动，直到找到和规则匹配的选择符，或者因为不匹配而退出</p>
<ul>
<li><p>避免使用通用选择器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.content * &#123; color: red; &#125;</span><br></pre></td></tr></table></figure>
<p>  浏览器匹配文档中所有的元素后分别向上逐级匹配class为content的元素，直到文档的根节点。因此其匹配开销是非常大的，所以应避免使用关键选择器是通配选择器的情况</p>
</li>
<li><p>避免使用标签或class选择器限制id选择器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* Not recommended */</span><br><span class="line">button#backButton &#123;…&#125;</span><br><span class="line">/* Recommended */</span><br><span class="line">#newMenuIcon &#123;…&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>避免使用标签限制class选择器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* Not recommended */</span><br><span class="line">treecell.indented &#123;…&#125;</span><br><span class="line">/* Recommended */</span><br><span class="line">.treecell-indented &#123;…&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>避免使用多层标签选择器，使用class选择器替换，减少css查找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* Not recommended */</span><br><span class="line">treeitem[mailfolder=&quot;true&quot;] &gt; treerow &gt; treecell &#123;…&#125;</span><br><span class="line">/* Recommended */</span><br><span class="line">.treecell-mailfolder &#123;…&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>避免使用子选择器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* Not recommended */</span><br><span class="line">treehead treerow treecell &#123;…&#125;</span><br><span class="line">/* Recommended */</span><br><span class="line">treehead &gt; treerow &gt; treecell &#123;…&#125;</span><br><span class="line">/* Much to recommended */</span><br><span class="line">.treecell-header &#123;…&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* Not recommended */</span><br><span class="line">#bookmarkMenuItem &gt; .menu-left &#123; list-style-image: url(blah) &#125;</span><br><span class="line">/* Recommended */</span><br><span class="line">#bookmarkMenuItem &#123; list-style-image: url(blah) &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="常用的CSS命名规则"><a href="#常用的CSS命名规则" class="headerlink" title="常用的CSS命名规则"></a>常用的CSS命名规则</h4><h5 id="页面结构"><a href="#页面结构" class="headerlink" title="页面结构"></a>页面结构</h5><blockquote>
<p>容器: container<br>页头：header<br>内容：content/container<br>页面主体：main<br>页尾：footer<br>导航：nav<br>侧栏：sidebar<br>栏目：column<br>页面外围控制整体佈局宽度：wrapper<br>左右中：left right center</p>
</blockquote>
<h5 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h5><blockquote>
<p>导航：nav<br>主导航：mainnav<br>子导航：subnav<br>顶导航：topnav<br>边导航：sidebar<br>左导航：leftsidebar<br>右导航：rightsidebar<br>菜单：menu<br>子菜单：submenu<br>标题: title<br>摘要: summary</p>
</blockquote>
<h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h5><blockquote>
<p>标志：logo<br>广告：banner<br>登陆：login<br>登录条：loginbar<br>注册：register<br>搜索：search<br>功能区：shop<br>标题：title<br>加入：joinus<br>状态：status<br>按钮：btn<br>滚动：scroll<br>标籤页：tab<br>文章列表：list<br>提示信息：msg<br>当前的: current<br>小技巧：tips<br>图标: icon<br>注释：note<br>指南：guild<br>服务：service<br>热点：hot<br>新闻：news<br>下载：download<br>投票：vote<br>合作伙伴：partner<br>友情链接：link<br>版权：copyright</p>
</blockquote>
<h3 id="JavaScript编码规范"><a href="#JavaScript编码规范" class="headerlink" title="JavaScript编码规范"></a>JavaScript编码规范</h3><h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><ul>
<li>命名要有意义，可读性强</li>
<li>声明变量必须加上<code>var</code>关键字，严格控制作用域</li>
<li>私有变量名用下划线<code>_</code>开头</li>
<li>参数大于3个时，应以对象形式作为参数集传递</li>
<li>一般变量名用下划线分隔方式或者驼峰方式</li>
<li><p>驼峰方式命名的变量第一个字母小写，剩下的每个有意义的单词的首字母大写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var class_name = &quot;sunny&quot;;</span><br><span class="line">var className = &quot;sunny&quot;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常量必须使用大写字符，并用下划线分隔</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var ID_USER;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数必须使用首字大写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Class()&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>boolean类型的变量使用is或has开头</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var is Ready = false;</span><br><span class="line">var hasMoreCommands = false;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="书写规范-1"><a href="#书写规范-1" class="headerlink" title="书写规范"></a>书写规范</h4><ul>
<li><p>即使只有一条语句也最好不要省略<code>{}</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (boolean) &#123;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>{}</code>代替<code>new Object()</code>，使用<code>[]</code>代替<code>new Array()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr = [], obj = &#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每个语句结束必须使用分号</p>
</li>
<li>尽量不要让每行超过120字符<br><em>超长的不可分割的代码例外，比如复杂的正则表达式</em><br><em>运算符处换行时，运算符必须在新行的行首</em><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (user.isAuthenticated()</span><br><span class="line">	&amp;&amp; user.isInRole(&apos;admin&apos;)</span><br><span class="line">	&amp;&amp; user.hasAuthority(&apos;add-admin&apos;)</span><br><span class="line">	|| user.hasAuthority(&apos;delete-admin&apos;)</span><br><span class="line">)&#123;</span><br><span class="line">	// code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="接口命名规范"><a href="#接口命名规范" class="headerlink" title="接口命名规范"></a>接口命名规范</h4><ul>
<li>可读性强，见名晓义</li>
<li>尽量不与jQuery社区已有的习惯冲突</li>
<li>尽量写全，不用缩写，除非是下面列表中约定的：<blockquote>
<p><code>options</code>：表示选项，与 <code>jQuery</code> 社区保持一致，不要用 <code>config</code>, <code>opts</code> 等<br><code>active</code>：表示当前，不要用 <code>current</code> 等<br><code>index</code>：表示索引，不要用 <code>idx</code> 等<br><code>trigger</code>：触点元素<br><code>triggerType</code>：表示触发类型、方式<br><code>context</code>：表示传入的 <code>this</code> 对象<br><code>object</code>：推荐写全，不推荐简写为 <code>o</code>, <code>obj</code> 等<br><code>element</code>：推荐写全，不推荐简写为 <code>el</code>, <code>elem</code> 等<br><code>length</code>：不要写成 <code>len</code>, <code>l</code><br><code>prev</code>：<code>previous</code> 的缩写<br><code>next</code>：next 下一个<br><code>constructor</code>：不能写成 <code>ctor</code><br><code>easing</code>：示动画平滑函数<br><code>min</code>：<code>minimize</code> 的缩写<br><code>max</code>：<code>maximize</code> 的缩写<br><code>DOM</code>：不要写成 <code>dom</code>, <code>Dom</code><br><code>.hbs</code>：使用 <code>hbs</code> 后缀表示模版<br><code>btn</code>：<code>button</code> 的缩写<br><code>link</code>：超链接<br><code>title</code>：主要文本<br><code>img</code>：图片路径（img标签src属性）<br><code>dataset</code>：html5 <code>data-xxx</code> 数据接口<br><code>theme</code>：主题<br><code>className</code>：类名<br><code>classNameSpace</code>：class 命名空间</p>
</blockquote>
</li>
</ul>
<h4 id="空格、缩进、空行"><a href="#空格、缩进、空行" class="headerlink" title="空格、缩进、空行"></a>空格、缩进、空行</h4><ul>
<li>语句中的必要空格和缩进，缩进的单位为四个空格</li>
<li><p><code>=</code>前后需要跟空格，建议数值操作符(如：<code>+</code>/<code>-</code>/<code>*</code>/<code>%</code>)两边留空</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;Tom&quot;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>for循环条件中，分号后留一空格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for( var i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">	// dosomething</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>变量声明语句，数组值，对象值及函数参数中的逗号后留一空格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = 0, b = 1, c = 2;</span><br><span class="line">var arr = [1, 2, 3];</span><br><span class="line">var obj = &#123;a: 1, b: 2, c: 3&#125;;</span><br><span class="line">function(a, b, c)&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>空行不要有空格，行尾不要有空格</p>
</li>
<li>逗号和冒号后一定要跟空格，点号前后不要出现空格</li>
<li>空对象和数组不要填入空格</li>
<li>不要吝啬空行，尽量使用空行将逻辑相关的代码块分割开，以提高程序的可读性</li>
<li>合理的格式化和缩进<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    getName: &quot;1&quot;,</span><br><span class="line">    setName: &quot;0&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (success) &#123;</span><br><span class="line">    doSomething(1);</span><br><span class="line">&#125; else if (fail) &#123;</span><br><span class="line">    doSomething(2);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    doSomething(3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">switch (variable) &#123;</span><br><span class="line">    case &apos;1&apos;:</span><br><span class="line">        // do...</span><br><span class="line">        break;</span><br><span class="line">    case &apos;2&apos;:</span><br><span class="line">        // do...</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        // do...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ul>
<li><p>建议转换成string时，使用<code>+ &#39;&#39;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// good</span><br><span class="line">num + &apos;&apos;;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">new String(num);</span><br><span class="line">num.toString();</span><br><span class="line">String(num);</span><br></pre></td></tr></table></figure>
</li>
<li><p>建议转换成number时，使用<code>+</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// good</span><br><span class="line">+str;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">Number(str);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>parseInt</code>时，建议加上进制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&quot;1&quot;, 10);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="True和False布尔值"><a href="#True和False布尔值" class="headerlink" title="True和False布尔值"></a>True和False布尔值</h4><ul>
<li>下列值在布尔表达式中结果为<code>false</code><blockquote>
<p>null<br>undefined<br>‘’ // 空字符串<br>0 //数字</p>
</blockquote>
</li>
<li>而下面的为<code>true</code><blockquote>
<p>‘0’ // 字符串<br>[] //空数组<br>{} // 空对象</p>
</blockquote>
</li>
<li>还有一些难以区分的表达式，以下表达式结果为<code>true</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Boolean(&apos;0&apos;) == true</span><br><span class="line">&apos;0&apos; != true</span><br><span class="line">0 != null</span><br><span class="line">0 == []</span><br><span class="line">0 == false</span><br><span class="line"></span><br><span class="line">Boolean(null) == false</span><br><span class="line">null != true</span><br><span class="line">null != false</span><br><span class="line"></span><br><span class="line">Boolean(undefined) == false</span><br><span class="line">undefined != true</span><br><span class="line">undefined != false</span><br><span class="line"></span><br><span class="line">Boolean([]) == true</span><br><span class="line">[] != true</span><br><span class="line">[] == false</span><br><span class="line"></span><br><span class="line">Boolean(&#123;&#125;) == true</span><br><span class="line">&#123;&#125; != true</span><br><span class="line">&#123;&#125; != false</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="不要在Array上使用for-in"><a href="#不要在Array上使用for-in" class="headerlink" title="不要在Array上使用for in"></a>不要在Array上使用for in</h4><p><code>for-in</code>循环只用于<code>object/map/hash</code>的遍历，对<code>Array</code>用<code>for-in</code>循环有时会出错，因为它不是从<code>0</code>到<code>length - 1</code>进行遍历，而是所有出现在对象及其原型链的键值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// Not recommended</span><br><span class="line">function printArray(arr) &#123;</span><br><span class="line">  for (var key in arr) &#123;</span><br><span class="line">    print(arr[key]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printArray([0,1,2,3]);  // This works.</span><br><span class="line"></span><br><span class="line">var a = new Array(10);</span><br><span class="line">printArray(a);  // This is wrong.</span><br><span class="line"></span><br><span class="line">a = document.getElementsByTagName(&apos;*&apos;);</span><br><span class="line">printArray(a);  // This is wrong.</span><br><span class="line"></span><br><span class="line">// Recommended</span><br><span class="line">function printArray(arr) &#123;</span><br><span class="line">  var l = arr.length;</span><br><span class="line">  for (var i = 0; i &lt; l; i++) &#123;</span><br><span class="line">    print(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="二元和三元操作符"><a href="#二元和三元操作符" class="headerlink" title="二元和三元操作符"></a>二元和三元操作符</h4><p>操作符始终写在前一行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var x = a ? b : c;</span><br><span class="line"></span><br><span class="line">var y = a ?</span><br><span class="line">    longButSimpleOperandB : longButSimpleOperandC;</span><br><span class="line"></span><br><span class="line">var z = a ?</span><br><span class="line">        moreComplicatedB :</span><br><span class="line">        moreComplicatedC;</span><br></pre></td></tr></table></figure></p>
<h4 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h4><p>三元操作符用于替代<code>if</code>条件判断语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Not recommended</span><br><span class="line">if (val != 0) &#123;</span><br><span class="line">  return foo();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  return bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Recommended</span><br><span class="line">return val ? foo() : bar();</span><br></pre></td></tr></table></figure></p>
<h4 id="amp-amp-和"><a href="#amp-amp-和" class="headerlink" title="&amp;&amp;和||"></a>&amp;&amp;和||</h4><p>二元布尔操作符是可短路的，只有在必要时才会计算到最后一项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Not recommended</span><br><span class="line">function foo(opt_win) &#123;</span><br><span class="line">  var win;</span><br><span class="line">  if (opt_win) &#123;</span><br><span class="line">    win = opt_win;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    win = window;</span><br><span class="line">  &#125;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">// Recommended</span><br><span class="line">function foo(opt_win) &#123;</span><br><span class="line">  var win = opt_win || window;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Not recommended</span><br><span class="line">if (node) &#123;</span><br><span class="line">  if (node.kids) &#123;</span><br><span class="line">    if (node.kids[index]) &#123;</span><br><span class="line">      foo(node.kids[index]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Recommended</span><br><span class="line">var kid = node &amp;&amp; node.kids &amp;&amp; node.kids[index];</span><br><span class="line">if (kid) &#123;</span><br><span class="line">  foo(kid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="jQuery规范"><a href="#jQuery规范" class="headerlink" title="jQuery规范"></a>jQuery规范</h4><p>建议使用最新版本的jQuery，版本越新，性能越好</p>
<h5 id="jQuery变量"><a href="#jQuery变量" class="headerlink" title="jQuery变量"></a>jQuery变量</h5><ul>
<li>存放jQuery对象的变量以<code>$</code>开头</li>
<li>将jQuery选择器返回的对象缓存到本地变量中复用</li>
<li>使用驼峰式命名变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var $myDiv = $(&quot;#myDiv&quot;);</span><br><span class="line">$myDiv.click(function()&#123;...&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="jQuery选择器"><a href="#jQuery选择器" class="headerlink" title="jQuery选择器"></a>jQuery选择器</h5><ul>
<li>尽可能的使用 ID 选择器，因为它会调用浏览器原生方法<code>document.getElementById</code>查找元素。当然直接使用原生<code>document.getElementById</code>方法性能会更好</li>
<li>在父元素中选择子元素使用<code>.find()</code>方法性能会更好，因为ID选择器没有使用到Sizzle选择器引擎来查找元素<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Not recommended</span><br><span class="line">var $productIds = $(&quot;#products .class&quot;);</span><br><span class="line"></span><br><span class="line">// Recommended</span><br><span class="line">var $productIds = $(&quot;#products&quot;).find(&quot;.class&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h5><ul>
<li>当要操作DOM元素的时候，尽量将其分离节点，操作结束后，再插入节点</li>
<li>使用字符串连接使用<code>array.join</code>要比<code>.append()</code>性能更好<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// Not recommended</span><br><span class="line">var $myList = $(&quot;#list&quot;);</span><br><span class="line">for(var i = 0; i &lt; 10000; i++)&#123;</span><br><span class="line">    $myList.append(&quot;&lt;li&gt;&quot;+i+&quot;&lt;/li&gt;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Recommended</span><br><span class="line">var $myList = $(&quot;#list&quot;);</span><br><span class="line">var list = &quot;&quot;;</span><br><span class="line">for(var i = 0; i &lt; 10000; i++)&#123;</span><br><span class="line">    list += &quot;&lt;li&gt;&quot;+i+&quot;&lt;/li&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">$myList.html(list);</span><br><span class="line"></span><br><span class="line">// Much to recommended</span><br><span class="line">var array = [];</span><br><span class="line">for(var i = 0; i &lt; 10000; i++)&#123;</span><br><span class="line">    array[i] = &quot;&lt;li&gt;&quot;+i+&quot;&lt;/li&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">$myList.html(array.join(&apos;&apos;));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h5><ul>
<li>如果需要，对事件使用自定义的<code>namespace</code>，这样容易解绑特定的事件，而不会影响到此DOM元素的其他事件监听</li>
<li>对Ajax加载的DOM元素绑定事件时尽量使用事件委托，事件委托允许在父元素绑定事件，子代元素可以响应事件，也包括Ajax加载后添加的子代元素<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Not recommended</span><br><span class="line">$(&quot;#list a&quot;).on(&quot;click&quot;, myClickHandler);</span><br><span class="line"></span><br><span class="line">// Recommended</span><br><span class="line">$(&quot;#list&quot;).on(&quot;click&quot;, &quot;a&quot;, myClickHandler);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="链式写法"><a href="#链式写法" class="headerlink" title="链式写法"></a>链式写法</h5><ul>
<li>尽量使用链式写法而不是用变量缓存或者多次调用选择器的方法</li>
<li>当链式写法超过三次或者因为事件绑定变得复杂后，使用换行和缩进保持代码可读性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#myDiv&quot;).addClass(&quot;error&quot;).show();</span><br><span class="line">$(&quot;#myLink&quot;)</span><br><span class="line">  .addClass(&quot;bold&quot;)</span><br><span class="line">  .on(&quot;click&quot;, myClickHandler)</span><br><span class="line">  .on(&quot;mouseover&quot;, myMouseOverHandler)</span><br><span class="line">  .show();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="性能优化-1"><a href="#性能优化-1" class="headerlink" title="性能优化"></a>性能优化</h4><h5 id="避免不必要的DOM操作"><a href="#避免不必要的DOM操作" class="headerlink" title="避免不必要的DOM操作"></a>避免不必要的DOM操作</h5><p>浏览器遍历 DOM 元素的代价是昂贵的。最简单优化DOM树查询的方案是，当一个元素出现多次时，将它保存在一个变量中，就避免多次查询 DOM 树了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Not recommended</span><br><span class="line">for (var i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">  document.getElementById(&quot;myList&quot;).innerHTML += &quot;&lt;span&gt;&quot; + i + &quot;&lt;/span&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">// Recommended</span><br><span class="line">var myList = &quot;&quot;;</span><br><span class="line">var myListHTML = document.getElementById(&quot;myList&quot;).innerHTML;</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">  myList += &quot;&lt;span&gt;&quot; + i + &quot;&lt;/span&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myListHTML = myList;</span><br></pre></td></tr></table></figure></p>
<h5 id="缓存数组长度"><a href="#缓存数组长度" class="headerlink" title="缓存数组长度"></a>缓存数组长度</h5><p>循环无疑是和JavaScript性能非常相关的一部分，通过存储数组的长度，可以有效避免每次循环重新计算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array(1000),</span><br><span class="line">    len, i;</span><br><span class="line">// Recommended - size is calculated only 1 time and then stored</span><br><span class="line">for (i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Not recommended - size needs to be recalculated 1000 times</span><br><span class="line">for (i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="异步加载第三方内容"><a href="#异步加载第三方内容" class="headerlink" title="异步加载第三方内容"></a>异步加载第三方内容</h5><p>当你无法保证嵌入第三发内容可以正常工作的时候，你需要考虑用异步加载这些代码，以免阻塞整个页面加载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line"></span><br><span class="line">    var script,</span><br><span class="line">        scripts = document.getElementsByTagName(&apos;script&apos;)[0];</span><br><span class="line"></span><br><span class="line">    function load(url) &#123;</span><br><span class="line">      script = document.createElement(&apos;script&apos;);</span><br><span class="line">      script.async = true;</span><br><span class="line">      script.src = url;</span><br><span class="line">      scripts.parentNode.insertBefore(script, scripts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    load(&apos;//apis.google.com/js/plusone.js&apos;);</span><br><span class="line">    load(&apos;//platform.twitter.com/widgets.js&apos;);</span><br><span class="line">    load(&apos;//s.widgetsite.com/widget.js&apos;);</span><br><span class="line"></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p>
<h5 id="避免使用jQuery实现动画"><a href="#避免使用jQuery实现动画" class="headerlink" title="避免使用jQuery实现动画"></a>避免使用jQuery实现动画</h5><ul>
<li>禁止使用<code>slideUp/Down()</code> <code>fadeIn/Out()</code>等方法</li>
<li>尽量不使用<code>animate()</code>方法</li>
</ul>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ul>
<li>如无必要，勿增注释</li>
<li><p>如有必要，尽量详尽</p>
<h5 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//名称</span><br><span class="line">var name = 0;</span><br></pre></td></tr></table></figure>
<h5 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h5><p>使用多个单行注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// code</span><br><span class="line">// code</span><br><span class="line">// code</span><br></pre></td></tr></table></figure>
<h5 id="函数-方法注释"><a href="#函数-方法注释" class="headerlink" title="函数/方法注释"></a>函数/方法注释</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 函数描述</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;string&#125; p1 参数1的说明</span><br><span class="line"> * @param &#123;string&#125; p2 参数2的说明，比较长</span><br><span class="line"> *     那就换行了.</span><br><span class="line"> * @param &#123;number=&#125; p3 参数3的说明（可选）</span><br><span class="line"> * @return &#123;Object&#125; 返回值描述</span><br><span class="line"> */</span><br><span class="line">function foo(p1, p2, p3) &#123;</span><br><span class="line">    var p3 = p3 || 10;</span><br><span class="line">    return &#123;</span><br><span class="line">        p1: p1,</span><br><span class="line">        p2: p2,</span><br><span class="line">        p3: p3</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>sublime中安装<a href="https://packagecontrol.io/packages/DocBlockr" target="_blank" rel="external">DocBlock</a>插件，方便注释编写</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HEXO搭建个人博客]]></title>
      <url>http://yy709593266.github.io/blog/2016/06/11/2016-06-11-start/</url>
      <content type="html"><![CDATA[<p>第一次使用hexo搭建个人博客，记录下搭建全过程。 <a id="more"></a></p>
<p>1、github上新建仓库blog；</p>
<p>2、安装hexo<br>首先要安装node环境，以及git<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo -g</span><br></pre></td></tr></table></figure></p>
<p>3、新建本地博客文件夹<br>hexo init filename<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &apos;blog&apos;</span><br></pre></td></tr></table></figure></p>
<p>生成的文件夹中的source文件夹用来存放博客正文内容</p>
<blockquote>
<p>source</p>
</blockquote>
<p>4、创建新博客(文章)<br>找到source文件夹，在该文件夹下的_posts文件夹下创建博客名为start的博客<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &apos;start&apos;</span><br></pre></td></tr></table></figure></p>
<p>5、更换主题(可选)：<br>github上clone下nexT主题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone nexT&apos;url</span><br></pre></td></tr></table></figure></p>
<p>注意将主题clone到theme文件夹中；</p>
<p>6、主题配置: <a href="http://theme-next.iissnan.com/" target="_blank" rel="external">http://theme-next.iissnan.com/</a><br>包括：标签页，分类，关于等…</p>
<p>7、站点配置中添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure></p>
<p>8、发布本地博客预览<br>hexo clean<br>hexo g：generator将md文件转换成html文件<br>hexo server: 启动本地服务<br>浏览器中输入localhost:4000预览</p>
<p>9、发布远程博客配置(这是我的)<br>站点配置文件中添加配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/yy709593266/yy709593266.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p>
<p>10、发布<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p>
<p>11、访问个人博客网站：<a href="http://yy709593266.github.io/">http://yy709593266.github.io/</a></p>
<p>最后感谢<a href="http://jiaochunxiao.github.io/" target="_blank" rel="external">大神</a>对我的支持和帮助。棒棒哒。。。哈哈哈</p>
]]></content>
    </entry>
    
  
  
</search>
