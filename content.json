{"meta":{"title":"袁媛-仙女很忙","subtitle":"仙女也要码砖不像话","description":null,"author":"袁媛","url":"http://yy709593266.github.io/blog"},"pages":[{"title":"about","date":"2016-06-11T07:03:09.000Z","updated":"2016-06-11T07:03:10.000Z","comments":true,"path":"about/index.html","permalink":"http://yy709593266.github.io/blog/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2016-06-11T07:05:06.000Z","updated":"2016-06-11T07:09:58.000Z","comments":true,"path":"categories/index.html","permalink":"http://yy709593266.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2016-06-11T07:05:20.000Z","updated":"2016-06-11T07:09:40.000Z","comments":true,"path":"tags/index.html","permalink":"http://yy709593266.github.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"20171203-对象的扩展","slug":"20171203-ES6对象的扩展","date":"2017-12-03T13:07:16.000Z","updated":"2018-01-04T15:09:03.000Z","comments":true,"path":"2017/12/03/20171203-ES6对象的扩展/","link":"","permalink":"http://yy709593266.github.io/blog/2017/12/03/20171203-ES6对象的扩展/","excerpt":"ES6对象的扩展","text":"ES6对象的扩展1、简洁表示法属性的简洁表示法：12345const foo = &apos;bar&apos;;const baz = &#123;foo&#125;;baz // &#123;foo: &quot;bar&quot;&#125;// 等同于const baz = &#123;foo: foo&#125;; 方法的简洁表示法12345678910111213const o = &#123; method() &#123; return &quot;Hello!&quot;; &#125;&#125;;// 等同于const o = &#123; method: function() &#123; return &quot;Hello!&quot;; &#125;&#125;; 模块输出变量就很适合使用简洁写法：123456789101112131415161718192021let ms = &#123;&#125;;function getItem (key) &#123; return key in ms ? ms[key] : null;&#125;function setItem (key, value) &#123; ms[key] = value;&#125;function clear () &#123; ms = &#123;&#125;;&#125;module.exports = &#123; getItem, setItem, clear &#125;;// 等同于module.exports = &#123; getItem: getItem, setItem: setItem, clear: clear&#125;; 2、属性名表达式ES6允许字面量方法（大括号方法）定义对象时，使用表达式作为对象的属性名(同样可以用于定义方法名)：123456let propKey = &apos;foo&apos;;let obj = &#123; [propKey]: true, [&apos;a&apos; + &apos;bc&apos;]: 123&#125;; 如果此时的表达式是一个对象，默认情况下会自动将对象转位字符串[object Object]:123456789const keyA = &#123;a: 1&#125;;const keyB = &#123;b: 2&#125;;const myObject = &#123; [keyA]: &apos;valueA&apos;, [keyB]: &apos;valueB&apos;&#125;;myObject // Object &#123;[object Object]: &quot;valueB&quot;&#125; 注：属性名表达式和简洁表示法不能同时使用 3、object.is()ES6的object.is()方法用来比较两个值是否严格相等，与===基本相等，不同之处在于两个： +0不等于-0 NaN等于自身基础用法为：12Object.is(+0, -0) // falseObject.is(NaN, NaN) // true 4、Object.assign()Object.assign(目标对象，源对象)该方法用于对象的合并，将源对象的所有可枚举属性（不拷贝继承属性，不拷贝不可枚举属性）复制到目标对象上：1234567const target = &#123; a: 1, b: 1 &#125;;const source1 = &#123; b: 2, c: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; 注意： 如果目标对象与源对象有同名属性，则后面的属性会覆盖前面的属性 如果参数不是对象，则会先转成对象再进行返回 由于undefined和null无法转成对象，所以它们作为参数（目标对象）时会报错 该方法实行的是浅拷贝，也就是说如果源对象某个属性的值是对象，那么目标对象拷贝的是这个对象的引用（该对象变化所有拷贝对象的该对象都会相应的变化） 在嵌套对象时，一旦遇到同名属性，该函数的处理方法时替换而不是添加： 1234const target = &#123; a: &#123; b: &apos;c&apos;, d: &apos;e&apos; &#125; &#125;const source = &#123; a: &#123; b: &apos;hello&apos; &#125; &#125;Object.assign(target, source)// &#123; a: &#123; b: &apos;hello&apos; &#125; &#125; 该函数用来处理数组时，会把数组视为对象（属性即为下标）： 12Object.assign([1, 2, 3], [4, 5])// [4, 5, 3] 使用该函数可以实现克隆对象： 123456789//只能克隆原始对象自身的值，不能克隆它继承的值function clone(origin) &#123; return Object.assign(&#123;&#125;, origin);&#125;//克隆对象，并保持继承性function clone(origin) &#123; let originProto = Object.getPrototypeOf(origin); return Object.assign(Object.create(originProto), origin);&#125; 使用该函数可以指定默认值Object.assign({}, DEFAULTS, options) 5、属性的可枚举性和遍历 for...in循环：只遍历对象自身的和继承的可枚举的属性。 Object.keys()：返回对象自身的所有可枚举的属性的键名。 JSON.stringify()：只串行化对象自身的可枚举的属性。 Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。 ES6规定，所有Class的原型的方法都是不可枚举的 Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）的键名。 Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有Symbol属性的键名。 Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是Symbol或字符串，也不管是否可枚举。注意：大多数时候，我们只关心对象自身的属性，所以，尽量不要使用for...in循环，而用`Object.keys() 6、__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()js的对象继承是通过原型链实现的，ES6提供了更多原型对象的操作方法,如果一个对象本身部署了__proto__属性，该属性的值就是对象的原型，无论从语义的角度还是从兼容性的角度，都不要使用这个属性，而应该用Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）来代替。 7、super关键字关键字super指向当前对象的原型对象123456789101112const proto = &#123; foo: &apos;hello&apos;&#125;;const obj = &#123; find() &#123; return super.foo; &#125;&#125;;Object.setPrototypeOf(obj, proto);obj.find() // &quot;hello&quot; JavaScript 引擎内部，super.foo等同于Object.getPrototypeOf(this).foo（属性）或Object.getPrototypeOf(this).foo.call(this)（方法）,因此下面代码的结果也就能理解了：1234567891011121314151617const proto = &#123; x: &apos;hello&apos;, foo() &#123; console.log(this.x); &#125;,&#125;;const obj = &#123; x: &apos;world&apos;, foo() &#123; super.foo(); &#125;&#125;Object.setPrototypeOf(obj, proto);obj.foo() // &quot;world&quot; 8、Object.keys()，Object.values()，Object.entries()前面已经说过，Object.keys()方法返回一个数组，成员是参数对象自身所有可遍历属性的键名，与其配套的方法Object.values()，Object.entries()作为遍历对象的补充手段，供for...of循环使用：1234567891011121314let &#123;keys, values, entries&#125; = Object;let obj = &#123; a: 1, b: 2, c: 3 &#125;;for (let key of keys(obj)) &#123; console.log(key); // &apos;a&apos;, &apos;b&apos;, &apos;c&apos;&#125;for (let value of values(obj)) &#123; console.log(value); // 1, 2, 3&#125;for (let [key, value] of entries(obj)) &#123; console.log([key, value]); // [&apos;a&apos;, 1], [&apos;b&apos;, 2], [&apos;c&apos;, 3]&#125; 9、对象的扩展运算符 扩展运算符...用于取出参数对象的所有可遍历属性，拷贝到当前对象中 1234567let z = &#123; a: 3, b: 4 &#125;;let n = &#123; ...z &#125;;n // &#123; a: 3, b: 4 &#125;let aClone = &#123; ...a &#125;;// 等同于let aClone = Object.assign(&#123;&#125;, a); 对象的解析赋值用于从一个对象取值（将所有可遍历的、但尚未被读取的属性），分配到指定的对象上面 1234let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;x // 1y // 2z // &#123; a: 3, b: 4 &#125; 解构赋值的拷贝是浅拷贝，即如果一个键的值时复合类型，那么解构赋值拷贝的是这个值的引用，而不是这个值的副本 1234let obj = &#123; a: &#123; b: 1 &#125; &#125;;let &#123; ...x &#125; = obj;obj.a.b = 2;x.a.b // 2 扩展运算符的解构赋值不能复制继承自原型对象的属性 123456let o1 = &#123; a: 1 &#125;;let o2 = &#123; b: 2 &#125;;o2.__proto__ = o1;let &#123; ...o3 &#125; = o2;o3 // &#123; b: 2 &#125;o3.a // undefined 上面那条规则说的是解构扩展运算符，当然，如果不是扩展运算符的解构赋值还是复制来自原型对象的属性 1234567const o = Object.create(&#123; x: 1, y: 2 &#125;);o.z = 3;let &#123; x, ...&#123; y, z &#125; &#125; = o;x // 1(单纯的解构赋值)y // undefinedz // 3 10、Null传导运算符实际项目中，如果读取对象内部的某个属性，往往需要判断一个该对象是否存在。比如，要读取message.body.user.firstName,安全的写法为1234const firstName = (message &amp;&amp; message.body &amp;&amp; message.body.user &amp;&amp; message.body.user.firstName) || &apos;default&apos;; 这样层层判断非常麻烦，由此引入Null传导运算符，简化上面的写法为：1const firstName = message?.body?.user?.firstName || &apos;default&apos;; 上面三个?.运算符，主要有一个返回null或undefined,就不再往下运算，而是返回undefined,更多例子如下：12345678910// 如果 a 是 null 或 undefined, 返回 undefined// 否则返回 a.b.c().da?.b.c().d// 如果 a 是 null 或 undefined，下面的语句不产生任何效果// 否则执行 a.b = 42a?.b = 42// 如果 a 是 null 或 undefined，下面的语句不产生任何效果delete a?.b","categories":[],"tags":[{"name":"-ES6","slug":"ES6","permalink":"http://yy709593266.github.io/blog/tags/ES6/"}]},{"title":"ES6数组的扩展","slug":"20171203-ES6数组的扩展","date":"2017-12-03T11:23:38.000Z","updated":"2017-12-03T13:05:54.000Z","comments":true,"path":"2017/12/03/20171203-ES6数组的扩展/","link":"","permalink":"http://yy709593266.github.io/blog/2017/12/03/20171203-ES6数组的扩展/","excerpt":"数组的扩展运算符，以及有关数组实例方法的扩展","text":"数组的扩展运算符，以及有关数组实例方法的扩展 1、扩展运算符...它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。123456789console.log(...[1, 2, 3])// 1 2 3function add(x, y) &#123; return x + y;&#125;const numbers = [4, 38];add(...numbers) // 42//...number将数组转位逗号分隔的参数序列，并带入函数中 扩展运算符可以复制数组数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组，扩展运算符提供了复制数组的简便写法： 123456const a1 = [1, 2];// 写法一const a2 = [...a1];// 写法二const [...a2] = a1;//上面两种写法中a2都是a1的克隆 扩展运算符可以合并数组 1234567891011var arr1 = [&apos;a&apos;, &apos;b&apos;];var arr2 = [&apos;c&apos;];var arr3 = [&apos;d&apos;, &apos;e&apos;];// ES5的合并数组arr1.concat(arr2, arr3);// [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ]// ES6的合并数组[...arr1, ...arr2, ...arr3]// [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ] 扩展运算符与解构赋值结合但是，注意，如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。 1234567891011121314151617const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest // [2, 3, 4, 5]const [first, ...rest] = [];first // undefinedrest // []const [first, ...rest] = [&quot;foo&quot;];first // &quot;foo&quot;rest // []const [...butLast, last] = [1, 2, 3, 4, 5];// 报错const [first, ...middle, last] = [1, 2, 3, 4, 5];// 报错 2、Array.from()Array.from()方法用于将两类对象转为真正的数组：类似数组的对象和可遍历的对象,例如常见的类似数组的对象是 DOM操作返回的NodeList集合，以及函数内部的arguments对象,所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组123456789101112131415let arrayLike = &#123; &apos;0&apos;: &apos;a&apos;, &apos;1&apos;: &apos;b&apos;, &apos;2&apos;: &apos;c&apos;, length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]// ES6的写法let arr2 = Array.from(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]Array.from(&#123; length: 3 &#125;);// [ undefined, undefined, undefined ] Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。123456Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9] 如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。 3、Array.of()Array.of方法用于将一组值，转换为数组。由于传统的Array方法存在的弊端，如：123Array() // []Array(3) // [, , ,]Array(3, 11, 8) // [3, 11, 8] 上面代码中，Array方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于2个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一:1234Array.of() // []Array.of(undefined) // [undefined]Array.of(1) // [1]Array.of(1, 2) // [1, 2] 4、copyWithin()该方法是指在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组，它接受三个参数：target（必需）：从该位置开始替换数据。start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。123[1, 2, 3, 4, 5].copyWithin(0, 3)// [4, 5, 3, 4, 5]//表示将从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2。 5、find()和findIndex()数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。123456[1, 4, -5, 10].find((n) =&gt; n &lt; 0)// -5[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。123[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。 6、fill()使用给定值，填充一个数组,该方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去，同时，该方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。12345678[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7)// [7, 7, 7]new Array(3).fill(7)// [7, 7, 7][&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7, 1, 2)// [&apos;a&apos;, 7, &apos;c&apos;] 7、entries()，keys()和values()这三个方法都是用于遍历数组，可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。1234567891011121314151617for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) &#123; console.log(elem);&#125;// &apos;a&apos;// &apos;b&apos;for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) &#123; console.log(index, elem);&#125;// 0 &quot;a&quot;// 1 &quot;b&quot; 8、includes()表示某个数组是否包含给定的值，与字符串的includes方法类似123[1, 2, 3].includes(2) // true[1, 2, 3].includes(4) // false[1, 2, NaN].includes(NaN) // true 没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值，indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判:12[NaN].indexOf(NaN)// -1 9、数组的空位数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位:1Array(3) // [, , ,] Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。 扩展运算符（...）也会将空位转为undefined。 copyWithin()会连空位一起拷贝。 fill()会将空位视为正常的数组位置。 for...of循环也会遍历空位。 entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。由于空位的处理规则非常不统一，所以建议避免出现空位。","categories":[],"tags":[{"name":"-ES6","slug":"ES6","permalink":"http://yy709593266.github.io/blog/tags/ES6/"}]},{"title":"ES6函数的扩展","slug":"20171023-ES6函数的扩展","date":"2017-10-23T14:49:47.000Z","updated":"2017-12-03T11:24:01.000Z","comments":true,"path":"2017/10/23/20171023-ES6函数的扩展/","link":"","permalink":"http://yy709593266.github.io/blog/2017/10/23/20171023-ES6函数的扩展/","excerpt":"相比于ES5，ES6对函数也做了一些扩展，比如允许对函数参数设置默认值等","text":"相比于ES5，ES6对函数也做了一些扩展，比如允许对函数参数设置默认值等 1、ES6允许为函数的参数设置默认值，即直接写在参数定义的后面：1234567function log(x, y = &apos;World&apos;) &#123; console.log(x, y);&#125;log(&apos;Hello&apos;) // Hello Worldlog(&apos;Hello&apos;, &apos;China&apos;) // Hello Chinalog(&apos;Hello&apos;, &apos;&apos;) // Hello 其中参数变量是默认声明的，所以不能再使用let或者const再次声明，否则会报错，所以一个函数也不能有相同的两个变量参数，这也就相当于重复声明（默认声明）了一个变量。另外，参数的默认值每次都是在调用的时候重新计算的，不是一直不变的：123456789let x = 99;function foo(p = x + 1) &#123; console.log(p);&#125;foo() // 100x = 100;foo() // 101 2、参数默认值可以与解构赋值的默认值，结合起来使用首先看下面一个例子：12345678function foo(&#123;x, y = 5&#125;) &#123; console.log(x, y);&#125;foo(&#123;&#125;) // undefined 5foo(&#123;x: 1&#125;) // 1 5foo(&#123;x: 1, y: 2&#125;) // 1 2foo() // TypeError: Cannot read property &apos;x&apos; of undefined 最后一个调用之所以会报错是因为，只有当函数的参数是一个对象时，变量x和y才能通过对象的解析赋值生成值，就相当于我调用这个函数的时候传了参数，首先第一步就是参数的解析赋值，比如传进来的参数是空对象{}时，那么首先进行解析赋值操作，即{x, y = 5} = {},解析赋值得到的结果就是{x, y = 5}，所以当传入的参数是空的时候，解析赋值出错自然就报错了。因此，通过提供函数参数的默认值就可以避免这种情况：12345function foo(&#123;x, y = 5&#125; = &#123;&#125;) &#123; console.log(x, y);&#125;foo() // undefined 5 同样的例子：123456789function fetch(url, &#123; body = &apos;&apos;, method = &apos;GET&apos;, headers = &#123;&#125; &#125;) &#123; console.log(method);&#125;fetch(&apos;http://example.com&apos;, &#123;&#125;)// &quot;GET&quot;fetch(&apos;http://example.com&apos;)// 报错 避免这种报错，应该写成以下格式：123456function fetch(url, &#123; body = &apos;&apos;, method = &apos;GET&apos;, headers = &#123;&#125; &#125; = &#123;&#125;) &#123; console.log(method);&#125;fetch(&apos;http://example.com&apos;)// &quot;GET&quot; 下面看两个很相近的例子：123456789// 写法一function m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;// 写法二function m2(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125; 上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值（就算不传参数，也会默认解构这个默认参数的赋值）；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值，即在以下几种赋值情况下得到的结果为：123456789101112131415161718// 函数没有参数的情况m1() // [0, 0]m2() // [0, 0]// x 和 y 都有值的情况m1(&#123;x: 3, y: 8&#125;) // [3, 8]m2(&#123;x: 3, y: 8&#125;) // [3, 8]// x 有值，y 无值的情况m1(&#123;x: 3&#125;) // [3, 0]m2(&#123;x: 3&#125;) // [3, undefined]// x 和 y 都无值的情况m1(&#123;&#125;) // [0, 0];m2(&#123;&#125;) // [undefined, undefined]m1(&#123;z: 3&#125;) // [0, 0]m2(&#123;z: 3&#125;) // [undefined, undefined] 3、函数的 length属性当函数指定了默认值以后，函数的length属性将返回没有被指定默认值的参数个数,即：123(function (a) &#123;&#125;).length // 1(function (a = 5) &#123;&#125;).length // 0(function (a, b, c = 5) &#123;&#125;).length // 2 如果设置了默认值的参数不是尾参数，那么函数的length值就是其之前未指定默认值的参数个数，即：12(function (a = 0, b, c) &#123;&#125;).length // 0(function (a, b = 1, c) &#123;&#125;).length // 1 4、设置默认值后函数的作用域一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的，例：1234567var x = 1;function f(x, y = x) &#123; console.log(y);&#125;f(2) // 2 如果f函数只有一个参数y=x的话，参数形成的单独的作用域中x就指向的是全局变量，得到的结果就是1，例如下面以函数作为参数,其道理相同：12345678let foo = &apos;outer&apos;;function bar(func = () =&gt; foo) &#123; let foo = &apos;inner&apos;; console.log(func());&#125;bar(); // outer 函数bar的参数默认值是一个匿名函数，返回值为变量foo。在函数参数形成的单独作用域里，并没有定义变量，所以foo指向全局变量，因此输出的就是outer，如果此时没有全局变量foo的话就会报错。来看一个终极例子：123456789var x = 1;function foo(x, y = function() &#123; x = 2; &#125;) &#123; var x = 3; y(); console.log(x);&#125;foo() // 3x // 1 foo函数的参数会形成一个单独的作用域，即：1234var x;var y = function()&#123; x = 2;&#125; 再到函数里面又定义了一个变量x，y的默认值是一个匿名函数，这个匿名函数内部的变量x指向的就是参数作用域内变量x，参数变量声明时其值等于全局变量为1，但是函数的第二个参数匿名函数内部将其赋值为2（内部作用域优先级较高），函数内部又声明了一个内部变量x ,该变量和参数的变量x不是同一个作用域，所以执行y后，内部变量x和外部变量x都没有改变，函数体内的作用域比参数形成的作用域优先级要高，因此，x就是函数体内的值，执行函数打印出的变量值即为最小作用域内的`x的值，虽然函数体内执行了y()，但是y()参数的作用域内的x值没有函数体内的赋值优先级高，因此执行foo()后得到的结果还是最小作用域的值，为3。（尼玛，绕晕了）。下面是另外一种情况：123456789var x = 1;function foo(x, y = function() &#123; x = 2; &#125;) &#123; x = 3; y(); console.log(x);&#125;foo() // 2x // 1 因此，如果将var x= 3的var去掉，函数内部没有重新定义变量x，只有将其赋值，也就是在上一个作用域内定义了变量，并且赋值了（类似于函数内定义变量不var的话就是定义了一个全局变量），因此执行foo()函数时，首先没找到函数内部定义的变量x，往上一级（参数作用域内）找，找到了，并且在执行y()的将其重新赋值为2，因此执行foo()函数时打印出的x的值为2。 5、rest参数函数的rest参数形式为（…values）,就不需要arguments对象了，利用这个参数可以给函数传入任意数目的参数。因为arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。rest参数之后不可以再有其他的参数，之前可以有，函数的length属性也不包括rest参数的，只包括其之前的参数。 6、箭头函数最基本的箭头函数如下：1234567var f = v =&gt; v;//多行代码需要使用大括号将代码块括起来//相等于var f = function(v) &#123; return v;&#125;; 下面看一个使用rest参数结合的箭头函数的返回值12345const headAndTail = (head, ...tail) =&gt; [head, tail];headAndTail(1, 2, 3, 4, 5)// [1,[2,3,4,5]]//因为rest参数是一个数组，所以tail返回的值就是一个数组 值的注意的是，在箭头函数中的this变量就是定义时的对象，而不是调用时所在的那个对象比如说setInterval（() =&gt; {})这个方法中函数里的this就不再是window对象了，而是当前上下文的this对象。this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。因此，下面代码中虽然层层嵌套了很多的箭头函数，但是却只有一个this,也就是foo()这个函数的this,因此值都为11234567891011121314function foo() &#123; return () =&gt; &#123; return () =&gt; &#123; return () =&gt; &#123; console.log(&apos;id:&apos;, this.id); &#125;; &#125;; &#125;;&#125;var f = foo.call(&#123;id: 1&#125;);var t1 = f.call(&#123;id: 2&#125;)()(); // id: 1var t2 = f().call(&#123;id: 3&#125;)(); // id: 1var t3 = f()().call(&#123;id: 4&#125;); // id: 1 7、双冒号运算符函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面,相当于ES5中apply,call,bind方法。如果左边是空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。123var method = obj::obj.foo;// 等同于var method = ::obj.foo; 8、尾调用就是指某个函数的最后一步是调用另一个函数。12345678910function f(x)&#123; return g(x);&#125;//或者function f(x) &#123; if (x &gt; 0) &#123; return m(x) &#125; return n(x);&#125; 值的注意的是，以下三种情况并不属于尾调用的范畴：123456789101112131415161718// 情况一function f(x)&#123; let y = g(x); return y;&#125;//因为调用后还有赋值// 情况二function f(x)&#123; return g(x) + 1;&#125;//调用后还有操作// 情况三function f(x)&#123; g(x);&#125;//其实最后一句是return undefined","categories":[],"tags":[{"name":"-ES6","slug":"ES6","permalink":"http://yy709593266.github.io/blog/tags/ES6/"}]},{"title":"ES6字符串和数值的扩展","slug":"20171022-ES6字符串和数值的扩展","date":"2017-10-22T09:14:12.000Z","updated":"2017-10-23T14:24:15.000Z","comments":true,"path":"2017/10/22/20171022-ES6字符串和数值的扩展/","link":"","permalink":"http://yy709593266.github.io/blog/2017/10/22/20171022-ES6字符串和数值的扩展/","excerpt":"ES6对字符串及其操作进行了扩展，使得操作字符串变得更加方便快捷；对数值的扩展主要是新增和对传统的数值函数进行了修改的使用。","text":"ES6对字符串及其操作进行了扩展，使得操作字符串变得更加方便快捷；对数值的扩展主要是新增和对传统的数值函数进行了修改的使用。 字符串的扩展1、ES6为字符串添加了遍历接口，使得字符串可以被for...of循环便利(相比传统的for循环最大的优点是可以识别大于0xFFFF的码点):123456for (let codePoint of &apos;foo&apos;) &#123; console.log(codePoint)&#125;// &quot;f&quot;// &quot;o&quot;// &quot;o&quot; 2、at()返回字符串给定位置的字符（相比传统的chatAt()方法可以识别大于0xFFFF的码点，返回正确的字符）：1&apos;abc&apos;.at(0) // &quot;a&quot; 3、includes(), startsWith(), endsWith()includes()：返回布尔值，表示是否找到了参数字符串;startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部;endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。这三个函数都支持第二个参数，表示开始搜索的位置：12345let s = &apos;Hello world!&apos;;s.startsWith(&apos;world&apos;, 6) // trues.endsWith(&apos;Hello&apos;, 5) // trues.includes(&apos;Hello&apos;, 6) // false 值得注意的是：使用第二个参数n时，endsWith的行为与其他两个方法有所不同,它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。 4、repeat() 该方法返回一个新字符串，表示将原字符串重复n次。 蚕食0时会返回一个空字符串。 参数如果是小数，会被取整（取小）。 如果repeat的参数是负数或者Infinity，会报错。 如果参数是0到-1之间的小数，则等同于0。 参数NaN等同于0。 如果repeat的参数是字符串，则会先转换成数字12&apos;na&apos;.repeat(&apos;na&apos;) // &quot;&quot;&apos;na&apos;.repeat(&apos;3&apos;) // &quot;nanana&quot; 5、padStart()，padEnd()字符串补全函数，padStart()用于头部补全，padEnd()用于尾部补全,这两个参数都接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。 如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串 12&apos;xxx&apos;.padStart(2, &apos;ab&apos;) // &apos;xxx&apos;&apos;xxx&apos;.padEnd(2, &apos;ab&apos;) // &apos;xxx&apos; 如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。 12&apos;abc&apos;.padStart(10, &apos;0123456789&apos;)// &apos;0123456abc&apos; 如果省略第二个参数，默认使用空格补全长度。 12&apos;x&apos;.padStart(4) // &apos; x&apos;&apos;x&apos;.padEnd(4) // &apos;x &apos; 6、模板字符串用反引号标识，它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量：12345678910111213// 普通字符串`In JavaScript &apos;\\n&apos; is a line-feed.`// 多行字符串`In JavaScript this is not legal.`console.log(`string text line 1string text line 2`);// 字符串中嵌入变量let name = &quot;Bob&quot;, time = &quot;today&quot;;`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 如上所示，模板字符串中嵌入变量需要将变量名写在${}中，其中大括号中可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性，调用函数等，但是，如果大括号中的变量未声明的话会报错。 模板字符串跟在一个函数名后面，该函数将被调用来处理这个模板字符串，被称为“标签模板”功能,也是调用函数的一种特殊形式：123alert`123`// 等同于alert(123) 但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数，这个比较复杂，看下面两个例子：1234567//例1let a = 5;let b = 10;tag`Hello $&#123; a + b &#125; world $&#123; a * b &#125;`;// 等同于tag([&apos;Hello &apos;, &apos; world &apos;, &apos;&apos;], 15, 50); 上面代码中，tag是函数名，该函数的第一个参数是一个数组，数组的成员是模板字符串中那些没有变量替换的部分，该函数的其他参数都是模板字符串各个变量被替换后的值，上述例子中，模板字符串中有两个变量，因此tag会接受到value1和value2两个参数，该函数的所有参数就如下：-第一个参数：[&#39;Hello&#39;, &#39;world&#39;, &#39;&#39;]-第二个参数：15-第三个参数：5012345678910111213141516171819202122//例2let total = 30;let msg = passthru`The total is $&#123;total&#125; ($&#123;total*1.05&#125; with tax)`;function passthru(literals) &#123;//等同于//function passthru(literals, value1, value2) &#123;//function passthru(litarals, ...values) &#123; let result = &apos;&apos;; let i = 0; while (i &lt; literals.length) &#123; result += literals[i++]; if (i &lt; arguments.length) &#123; result += arguments[i]; &#125; &#125; return result;&#125;//这里参数形式为（[&apos;The total is&apos;,&apos;(&apos;,&apos;with tax)&apos;],30,31.5）msg // &quot;The total is 30 (31.5 with tax)&quot; 模版处理函数的第一个参数（模版字符串数组）还有一个raw属性，保存的是转义后的原字符串：1234567tag`First line\\nSecond line`function tag(strings) &#123; console.log(strings.raw[0]); // strings.raw[0] 为 &quot;First line\\\\nSecond line&quot; // 打印输出 &quot;First line\\nSecond line&quot;&#125; 上述代码中，tag函数的第一个参数strings，有一个raw属性，也指向一个数组。该数组的成员与strings数组完全一致,唯一的区别就是字符串里面的斜杠都被转义了，此时\\\\n被转义，不再是一个换行符了，这是为了方便取得转义之前的原始模板而设计的。 7、String.raw()ES6的原生字符串都有一个raw方法，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串，如果原字符串的斜杠已经转义，那么String.raw不会做任何处理:12345String.raw`Hi\\n$&#123;2+3&#125;!`;// &quot;Hi\\\\n5!&quot;String.raw`Hi\\\\n`// &quot;Hi\\\\n&quot; String.raw函数的代码如下：123456789String.raw = function (strings, ...values) &#123; let output = &quot;&quot;; for (let index = 0; index &lt; values.length; index++) &#123; output += strings.raw[index] + values[index]; &#125; output += strings.raw[index] return output;&#125; 因此，当该函数作为作为正常的普通函数使用时，第一个参数应该是一个具有raw属性的对象，且raw属性的值应该是一个数组:12345String.raw(&#123; raw: &apos;test&apos; &#125;, 0, 1, 2);// &apos;t0e1s2t&apos;// 等同于String.raw(&#123; raw: [&apos;t&apos;,&apos;e&apos;,&apos;s&apos;,&apos;t&apos;] &#125;, 0, 1, 2); 数值的扩展1、ES6提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示;2、在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法,与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false;3、ES6将全局方法parseInt()和parseFloat()移植到Number对象上面，行为完全保持不变（逐步减少全局性方法，使得语言逐步模块化）;4、Number.isInteger()用来判断一个值是否为整数;5、Math.trunc方法用于去除一个数的小数部分，返回整数部分（对于非数值，内部使用Number方法将其转为数值，对于空值和无法截取整数的值，返回NaN）;6、Math.sign方法用来判断一个数到底是正数、负数、还是零(对于非数值，会先将其转换为数值，无法转为数值的值，会返回NaN);7、Math.cbrt方法用于计算一个数的立方根（对于非数值，内部使用Number方法将其转为数值，对于空值和无法截取整数的值，返回NaN）;8、ES6还新增了一些数值的计算方法，如Math.hypot方法返回所有参数的平方和的平方根(对于非数值，内部使用Number方法将其转为数值，只要有一个参数无法转为数值，就会返回NaN)以及一些对数相关方法，双曲函数方法，指数运算符和其他运算符等(不过用的不多，就先这些吧)…","categories":[],"tags":[{"name":"-ES6","slug":"ES6","permalink":"http://yy709593266.github.io/blog/tags/ES6/"}]},{"title":"ES6常用语法","slug":"20170912-ES6声明变量和解构赋值","date":"2017-09-12T14:24:00.000Z","updated":"2017-10-25T15:11:07.000Z","comments":true,"path":"2017/09/12/20170912-ES6声明变量和解构赋值/","link":"","permalink":"http://yy709593266.github.io/blog/2017/09/12/20170912-ES6声明变量和解构赋值/","excerpt":"ES6中let和const声明变量，变量的解构赋值。。。","text":"ES6中let和const声明变量，变量的解构赋值。。。 1、letlet和var的用途差不多，也是用来声明变量的，但是具体用途还是有些不一样。ES5中只有全局作用域和函数作用域，不存在其他的块级作用域，例如：1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 所以在ES5中声明的变量都是全局变量（除了在函数中），就容易产生变量泄漏，典型的案例就是在循环中，例如：1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 上面循环中，i是var声明的，是全局变量，所以i的值就是最后的值，即每次循环i的新值都会覆盖旧值，所有的i都指向同一个i所以最后都是10，而使用let声明的变量是有块级作用域的，例如：1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 由于for循环中循环变量是一个父作用域，循环体是一个单独的子作用域，同时上面循环中变量i是let出来的，所以当前的i只在本轮循环中有效，不会出现新值覆盖旧值的情况（因为javascript引擎会内部会记住上一轮循环的值，初始化本轮的变量i时就是在上一轮基础上进行计算的，因此，即使每次循环变量都被重新声明了，还是能够根据上一轮的值从而计算出本轮的值）。 let声明的变量不会有变量提升，即如果在声明之前调用变量会直接报错，而不再是报undefined； 使用let重复声明变量也会报错； 只要区块中存在let或者const命令，这个区块对这些命令声明的变量就形成了封闭作用域，凡是在声明之前就使用这些变量都会报错： 1234567891011if (true) &#123; // “暂时性死锁” tmp = &apos;abc&apos;; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125; 不能在函数内部使用let重新声明传进来的参数，否则会报错 12345678910111213function func(arg) &#123; let arg; console.log(arg);&#125;func(&apos;kkk&apos;); // 报错(使用var重新申明参数不会报错)function func(arg) &#123; &#123; let arg; // 不报错 console.log(arg); &#125;&#125;func(&apos;kkk&apos;); //undefined(此时arg是在单独的一个作用內重新申明的一个参数) let声明变量不再是window对象的变量，例如： 123456var a = 1;// 或者采用通用方法，写成this.awindow.a // 1let b = 1;window.b // undefined 2、const const声明一个只读的常量，一旦声明，就不能再修改，如果强行修改就会报错。所以，在声明变量时就要立即赋值，不能留到以后再赋值，而且，如果只声明不赋值的话也会直接报错; const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用; 也与let一样不可重复声明; const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。例如：12345const foo = &#123;&#125;;foo.prop = 123;foo.prop // 123foo = &#123;&#125;; // TypeError: &quot;foo&quot; is read-only 这里，定义foo时候，foo存储的是一个地址，这个地址指向一个对象（即一个指针，这个指针是不能再变的），不可变的是这个指针，不能再让foo指向其他地址，这样会报错，但是可以对foo指向的那个地址的对象添加属性 3、变量的解构赋值（从数组和对象中提取值来对变量进行赋值） 等号两边都是数组，这种写法需要“模式匹配”，即左右两边的模式需要相同，如果解构不成功，变量值就是undefined。 123456789101112131415let [a, b, c] = [1, 2, 3]; //从数组中提取值对变量a，b，c进行赋值let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = [&apos;a&apos;];x // &quot;a&quot;y // undefinedz // []let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 解构赋值允许指定默认值 123let [foo = true] = []; foo // truelet [x, y = &apos;b&apos;] = [&apos;a&apos;, undefined]; // x=&apos;a&apos;, y=&apos;b&apos; 注意：只有该成员变量的值严格等于undefined时，此时指定的默认值才会生效，就是说如果一个数组成员不严格等于undefined，此时指定的默认值不会生效，如：12let [x = 1] = [null];x // null(此时给x赋的值不再是undefined，因为null!==undefined的) 默认值可以引用解构赋值的其他变量，但该变量必须已经声明,如：1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError 4、对象的解构赋值 对象的解构赋值中，变量的取值不再由它的位置决定，变量必须与属性同名才能取到正确的值，如：123let &#123; bar, foo &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;foo // &quot;aaa&quot;bar // &quot;bbb&quot; 上面的例子其实是下面这个例子的简写：123let &#123; bar: bar, foo: foo &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;foo // &quot;aaa&quot;bar // &quot;bbb&quot; 所以：12let &#123; foo: baz &#125; = &#123; foo: &apos;aaa&apos;, bar: &apos;bbb&apos; &#125;;baz // &quot;aaa&quot; 下面是另外一个例子：12345678910111213const node = &#123; loc: &#123; start: &#123; line: 1, column: 5 &#125; &#125;&#125;;let &#123; loc, loc: &#123; start &#125;, loc: &#123; start: &#123; line &#125;&#125; &#125; = node;line // 1loc // Object &#123;start: Object&#125;start // Object &#123;line: 1, column: 5&#125; 这里要注意的是：最后一次对line属性的解构赋值之中，只有line是变量，loc和start都是模式，不再是变量了。对象的解构也可以指定默认值，条件也是对象的属性值严格等于undefined12345var &#123;x = 3&#125; = &#123;x: undefined&#125;;x // 3var &#123;x = 3&#125; = &#123;x: null&#125;;x // null 如果解构失败，变量的值等于undefined 12let &#123;foo&#125; = &#123;bar: &apos;baz&apos;&#125;;foo // undefined 以上的解构都是在声明变量的时候对变量进行解构赋值，如果对已经声明过的变量进行解析赋值，要注意： 12345678// 错误的写法let x;&#123;x&#125; = &#123;x: 1&#125;;// SyntaxError: syntax error// 正确的写法let x;(&#123;x&#125; = &#123;x: 1&#125;); 因为JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。 对象的解构赋值还有一个很方便的功能，就是可以和方便的将现有的对象的方法赋值到某个变量，下面的语句就将Math对象的log，sin，cos方法赋值给了相应的三个变量: 1let &#123; log, sin, cos &#125; = Math; 由于数组本质上就是特殊的对象，因此可以对数组进行对象属性的解构： 1234let arr = [1, 2, 3];let &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3 5、字符串的解构赋值对字符串进行解构赋值时，字符串被转换成了一个类似数组的对象，由于类似数组的对象都有一个length属性，因此还可以对这个属性进行赋值：123456789const [a, b, c, d, e] = &apos;hello&apos;;a // &quot;h&quot;b // &quot;e&quot;c // &quot;l&quot;d // &quot;l&quot;e // &quot;o&quot;let &#123;length : len&#125; = &apos;hello&apos;;len // 5 6、函数参数的解构赋值 首先看一个简单的例子：12345function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 下面是另一个例子：12[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ] 函数参数的解构也可以使用默认值下面看两个不同形式的默认值参数的解构赋值：123456789101112131415161718function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0]function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0] 第一种是对变量x和y进行解构，解构失败就等于默认值0，如果不传参也有默认参数都为0第二种是函数参数指定默认值，如果不传参当然就是undefined 总的来说，解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象（由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错）。","categories":[],"tags":[{"name":"-ES6","slug":"ES6","permalink":"http://yy709593266.github.io/blog/tags/ES6/"}]},{"title":"那些后知后觉的笔面试题","slug":"20161119-笔面试题","date":"2016-11-19T09:28:26.000Z","updated":"2017-09-12T14:19:42.000Z","comments":true,"path":"2016/11/19/20161119-笔面试题/","link":"","permalink":"http://yy709593266.github.io/blog/2016/11/19/20161119-笔面试题/","excerpt":"找工作的日子是难熬的，找完工作的日子是无聊的，难得无聊的日子也不能自我放弃喽，趁着这个悠（wu）闲（liao）的日子里，把那些月子里锻（zhe）炼（mo）我的笔试和面试遇题做一个集锦，以备不时之需（😂😂）","text":"找工作的日子是难熬的，找完工作的日子是无聊的，难得无聊的日子也不能自我放弃喽，趁着这个悠（wu）闲（liao）的日子里，把那些月子里锻（zhe）炼（mo）我的笔试和面试遇题做一个集锦，以备不时之需（😂😂） 1、给定几个数，写出一个方法，将这几个数拼接出最大整数1234567891011function MaxNum(arr)&#123; arr = arr.sort(); var len = arr.length; var result = &quot;&quot;; for(var i = len - 1; i &gt;= 0; i--) &#123; result += arr[i]; &#125; return parseInt(result);&#125;var arr = [1, 13, 5];console.log(MaxNum(arr)); //5131 arrayObject.sort(sortby)方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定顺序。参数可选，在没有使用参数的时候，按照字符串编码的顺序进行排序；如果想按照其它标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字，比较函数应该具有两个参数a和b，其返回值如下，若a小于b，在排序后的数组中a应该出现在b之前，则返回一个小于0的值，若a等于b，则返回0，若a大于b，则返回一个大于0的值，sort根据这个函数返回的结构对这个数组进行冒泡排序(即，根据返回－1的那个条件来排序)，假如我们想要降序排序这个数组：123456789101112var arr = [1, 13, 5];function compare(a, b)&#123; if(a &lt; b) &#123; return -1; &#125;else if(a &gt; b) &#123; return 1; &#125;else &#123; return 0; &#125;&#125;arr.sort(compare);console.log(arr); //[1, 5, 13] 2、我太懒了。。。待续","categories":[],"tags":[{"name":"-笔面试题","slug":"笔面试题","permalink":"http://yy709593266.github.io/blog/tags/笔面试题/"}]},{"title":"从psd photo到css style","slug":"20160904(psd-css)","date":"2016-09-04T09:28:26.000Z","updated":"2016-11-19T08:35:10.000Z","comments":true,"path":"2016/09/04/20160904(psd-css)/","link":"","permalink":"http://yy709593266.github.io/blog/2016/09/04/20160904(psd-css)/","excerpt":"如何将视觉美眉给的psd图用CSS样式表示出来对于前端工作人员来说是一个很重要的问题，特别是细节，比如颜色、阴影效果等。因为对photoshop本来就不是很熟，所以对平时自己慢慢积累用到的一些关于photoshop的技巧和方法实时记下来，以免回头一顿火锅的时间就给忘了（此时在北京实习的日子很是想念火锅，重庆火锅！对！我很爱吃火锅！！！）。","text":"如何将视觉美眉给的psd图用CSS样式表示出来对于前端工作人员来说是一个很重要的问题，特别是细节，比如颜色、阴影效果等。因为对photoshop本来就不是很熟，所以对平时自己慢慢积累用到的一些关于photoshop的技巧和方法实时记下来，以免回头一顿火锅的时间就给忘了（此时在北京实习的日子很是想念火锅，重庆火锅！对！我很爱吃火锅！！！）。 切图方法一 工具栏自动选择图层选中 窗口中打开图层工具条 选中想要切的图，点击后图层工具栏中会自动选中该图层 图层工具栏中在选中的图层上右击－&gt;转换成智能对象 图层工具栏中双击已被转换成智能对象的图层前面的图标 弹出的窗口点击确定（现在就自动新建了一个画布将你要切的图复制过去了） 新建的画布中存储刚切出来的图并保存为web存储格式即可注意⚠️：如果想要切的图是几个图层的话就可以按住Ctrl键，同时选中后再一起转换成智能对象，后面的步骤都相同。🙏：感谢叶师傅 方法二如果想要的图是100＊100的，而psd给的该图标的大小只有80＊70，为了得到想要的大小的图100＊100，可以给图指定一个大小（100＊100）再切，这样切出来的图不会失真而且大小还是自己想要的（给多余的宽高背景都透明）。 工具栏自动选中图层选中 窗口中打开图层工具栏 选中想要切的图，点击后图层工具栏中会自动选中该图层 按住Alt键同时点击图层窗口中选中图层前面的小眼睛（以此来隐藏其它图层） 选中选框工具，并在上面工具栏中样式选中固定大小（或者固定比例），输入宽高值，得到自定义选框 点击psd图移动选框位置使得想要切的图在选框居中位置（大概居中，还没发现一个绝对居中的方法） 点击裁切工具确定裁切并保存为web存储格式即可注意⚠️：裁切完以后一定要到历史工具栏中恢复一下，不然整张图就没切成这么一点了，原图就没啦。 获取阴影效果有时候视觉美眉给的一张psd图有些部分会是阴影效果，这时候写CSS样式时，需要根据psd给定的阴影效果写参数： 选中阴影元素 图层工具栏中双击该图层（双击空白处） 出现一个弹窗，里面有该阴影的信息，现在根据这些信息就能计算出CSS样式中box－shadow的值了已知box－shadow值有五个参数，根据以上信息计算出五个参数具体值：参数1: 距离＊cos(180-角度)px;参数2: 距离＊sin(180-角度)px;参数3: (大小－参数4)px;参数4: 大小＊扩展(0%-100%)px;参数5: rgba()(点击混合后面一个颜色区域可以获取rgb值，a不透明度)。这种图给出的值计算出来的box－shadow参数值就是：参数1: 20＊cos(90) = 0px;参数2: 20＊sin(90) = 20px;参数3: 25-0 ＝ 25px;参数4: 25＊0% ＝ 0px;参数5: rgba(113, 135, 169, .25)。即box-shadow: 0px 20px 25px 0px rgba(113, 135, 169, .25)。","categories":[],"tags":[{"name":"-psd","slug":"psd","permalink":"http://yy709593266.github.io/blog/tags/psd/"}]},{"title":"javascript继承","slug":"20160829(javascript继承)","date":"2016-08-29T09:28:26.000Z","updated":"2016-11-15T12:48:02.000Z","comments":true,"path":"2016/08/29/20160829(javascript继承)/","link":"","permalink":"http://yy709593266.github.io/blog/2016/08/29/20160829(javascript继承)/","excerpt":"javascript在ES6之前，我们通过构造函数来创造一个类，并且通过原型来扩展属性，然后可以这样实现继承，这里主要说明这种继承方式各个构造函数原型之间的关系，顺便聊聊如何通过ES6实现继承。","text":"javascript在ES6之前，我们通过构造函数来创造一个类，并且通过原型来扩展属性，然后可以这样实现继承，这里主要说明这种继承方式各个构造函数原型之间的关系，顺便聊聊如何通过ES6实现继承。 构造函数1234567891011function Person(name, age, sex)&#123; this.name = name; this.age = age; this.sex = sex;&#125;Person.prototype.personLogAge = function()&#123; console.log(this.age);&#125;let person1 = new Person(&apos;xiao&apos;, 20, &apos;male&apos;);console.log(person1); 实例化一个Person命名为person1：一个对象A的_proto_属性指向的那个对象B就是它的原型对象（或者叫上级对象，父对象）。 继承－1123456789101112131415161718192021222324function Person(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender;&#125;Person.prototype.personLogAge = function()&#123; console.log(this.age);&#125;function Personal(name, age, gender, occupation, hobby) &#123; Person.call(this, name, age, gender); this.occupation = occupation; this.hobby = hobby;&#125;Personal.prototype = Object.create(Person.prototype);// Personal.prototype.constructor = Personal; //显示声明Personal类的constructorPersonal.prototype.personalLogAge = function()&#123; console.log(this.age);&#125;let person1 = new Person(&apos;xiao&apos;, 20, &apos;male&apos;);console.log(person1);let personal1 = new Personal(&apos;yuan&apos;, 17, &apos;female&apos;, &apos;web&apos;, &apos;travel&apos;);console.log(personal1); 实例化一个Personal命名为personal1:Object.create()是一种新的对象创建方式，第一个参数必需，要用作原型的对象，第二个参数可选，包含一个或多个属性描述符的javascript对象。 继承－212345678910111213141516171819202122232425262728293031323334353637function Person(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender;&#125;Person.prototype.personLogAge = function()&#123; console.log(this.age);&#125;function Personal(name, age, gender, occupation, hobby)&#123; Person.call(this, name, age, gender); this.occupation = occupation; this.hobby = hobby;&#125;Personal.prototype = Object.create(Person.prototype);Personal.prototype.constructor = Personal;Personal.prototype.personalLogAge = function()&#123; console.log(this.age);&#125;function Biology(name, age, gender, occupation, hobby) &#123; Personal.call(this, name, age, gender, occupation, hobby);&#125;Biology.prototype = Object.create(Personal.prototype);Biology.prototype.constructor = Biology;Biology.prototype.biologyLogAge = function()&#123; console.log(this.age);&#125;let person1 = new Person(&apos;xiao&apos;, 20, &apos;male&apos;);console.log(person1);let personal1 = new Personal(&apos;yuan&apos;, 17, &apos;female&apos;, &apos;web&apos;, &apos;travel&apos;);console.log(personal1);let biology = new Biology(&apos;yuan&apos;, 17, &apos;female&apos;, &apos;web&apos;, &apos;travel&apos;)console.log(biology1); 实例化一个Biology命名为biology1：以此类推实现继承。 ES6类ES6中出现了类的概念，ES6提供了更多的语法躺，可以直接创造一个类：12345678910111213141516171819class Person &#123; constructor(name, age, sex) &#123; this.name = name; this.age = age; this.sex = sex; &#125; personLogAge()&#123; console.log(this.age); &#125; personLogName()&#123; console.log(this.name); &#125; personLogSex()&#123; console.log(this.sex); &#125;&#125;let person1 = new Person(&apos;yuan&apos;, 17, &apos;female&apos;);console.log(person1); 通过ES6方法定义一个类，实例化一个Person命名为person1：ES6方法写的类内部所有定义的方法都是不可枚举的（non－enumberable），这也就是为什么实例只能看到它的属性值，使用Object.keys(person1)可以看到可以枚举的属性只有[&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;]，这一点和ES5行为不一致。 ES6继承1234567891011121314151617181920212223242526272829303132class Person &#123; constructor(name, age, sex) &#123; this.name = name; this.age = age; this.sex = sex; &#125; personLogAge()&#123; console.log(this.age); &#125; personLogName()&#123; console.log(this.name); &#125; personLogSex()&#123; console.log(this.sex); &#125;&#125;class Personal extends Person &#123; constructor(name, age, sex, occupation, hobby) &#123; super(name, age, sex); this.occupation = occupation; this.hobby = hobby; &#125; personalLogAge()&#123; console.log(this.age); &#125;&#125;let person1 = new Person(&apos;yuan&apos;, 17, &apos;female&apos;);console.log(person1);let personal1 = new Personal(&apos;xiao&apos;, 21, &apos;male&apos;, &apos;web&apos;, &apos;coding&apos;);console.log(personal1); Personal类继承了Person类，实例化一个Personal命名为personal1:","categories":[],"tags":[{"name":"-继承","slug":"继承","permalink":"http://yy709593266.github.io/blog/tags/继承/"}]},{"title":"IE9-jQuery-ajax","slug":"20160803(IE9-jQuery-ajax)","date":"2016-08-03T09:28:26.000Z","updated":"2016-11-15T11:58:46.000Z","comments":true,"path":"2016/08/03/20160803(IE9-jQuery-ajax)/","link":"","permalink":"http://yy709593266.github.io/blog/2016/08/03/20160803(IE9-jQuery-ajax)/","excerpt":"最近项目中使用jQuery的ajax发送跨域请求获取数据时，在IE9中请求未发送出去，最后找到大神解决了","text":"最近项目中使用jQuery的ajax发送跨域请求获取数据时，在IE9中请求未发送出去，最后找到大神解决了 一般的请求12345678$.ajax(&#123; type: &apos;GET&apos;, crossDomain: true, success: function(msg)&#123; //do something with your recieved message &#125;, error: function()&#123;&#125;&#125;); 兼容IE9的请求1234567891011121314151617181920212223if(window.XDomainRequest)&#123; var xdr = new XDomainRequest(); var query = yourUrl; if(xdr) &#123; xdr.onload = function()&#123; var msg = JSON.parse(xdr.responseText); // do something with your recieved message &#125;; xdr.onerror = function()&#123;&#125;; xdr.open(&apos;GET&apos;, query); xdr.send(); &#125;&#125;else &#123; $.ajax(&#123; type: &apos;GET&apos;, url: yourUrl, crossDomain: true, success: function(msg)&#123; //do something with your recieved message &#125;, error: function()&#123;&#125; &#125;);&#125; 🙏：感谢阔阔师傅","categories":[],"tags":[{"name":"-ajax -jQuery","slug":"ajax-jQuery","permalink":"http://yy709593266.github.io/blog/tags/ajax-jQuery/"}]},{"title":"ajaxFileUpload插件上传图片","slug":"20160726(ajaxFileUpload图片上传)","date":"2016-07-26T09:28:26.000Z","updated":"2016-11-15T12:49:33.000Z","comments":true,"path":"2016/07/26/20160726(ajaxFileUpload图片上传)/","link":"","permalink":"http://yy709593266.github.io/blog/2016/07/26/20160726(ajaxFileUpload图片上传)/","excerpt":"最近在项目中遇到一个照片上传的需求，用到了ajaxFileUpload的jQuery插件，中间遇到很多问题，不是缺少函数定义就是出现只能上传一次的问题，在这里对ajaxFileUpload插件使用中的问题做个总结。","text":"最近在项目中遇到一个照片上传的需求，用到了ajaxFileUpload的jQuery插件，中间遇到很多问题，不是缺少函数定义就是出现只能上传一次的问题，在这里对ajaxFileUpload插件使用中的问题做个总结。 插件引入因为ajaxFileUpload插件是基于jQuery的插件，所以引入这个插件之前需要先引入jQuery插件：12&lt;script src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;ajaxFileUpload.js&quot;&gt;&lt;/script&gt; 问题一:handleErrorinput标签提供一个直接上传文件的属性：123456789101112131415161718//html&lt;input name=&quot;file&quot; id=&quot;upload&quot; type=&quot;file&quot;&gt;//js$(&apos;#upload&apos;).on(&apos;change&apos;, function()&#123; $.ajaxFileUpload(&#123; url: &apos;xxx/xxx/xxx&apos;, //请求地址 type: &apos;post&apos;, //请求方式 secureuri: false, //是否启用安全提交，默认false fileElementId: &apos;upload&apos;,//上传input的id success: function(data, status)&#123; console.log(data); &#125;, error: function(data, status, e)&#123; console.log(data.msg); &#125; &#125;);&#125;); 这里选中图片确定以后触发input的onchange事件，此时发送请求将图片信息传给后台并获取后台返回数据，这里后台会给每次提交的图片返回一个特定的id，提交时候就将这个id提交给后台将图片保存起来，以后要访问图片就将src指定这张图片地址就行了。如果点击选中图片后再删除这张图片，那么虽然这张图片点击选中时后台返回了一个指定id，但是在提交表单的时候这张图片的id是不需要传给后台的，因为用户可能手抖点错了照片，不需要保存这张先选中后来被删除的照片的地址的(有点绕)。第一个问题就是，提示handleError is not a function，根据网上搜到的解决办法，就是复制一份这个函数到ajaxFileUpload函数中：1234567891011handleError: function(s, xhr, status, e)&#123; // If a local callback was specified, file it if(s.error)&#123; s.error.call(s.context || s, xhr, status, e); &#125; //File the global callback if(s.global)&#123; (s.context ? jQuery(s.context) : jQuery.event).trigger(&quot;ajaxError&quot;, [xhr, s, e]); &#125;&#125; 这里有一份已经添加完handleError函数的ajaxFileUpload文件，好了，这样就不会报handleError is not a function的错了。 问题二：data请求success时候返回的数据data应该就是后台返回的我们需要的值了，但是直接console.log出来发现，又有问题了，数据被一层不知道哪儿来的标签包住了，这里我们需要对接收到的data进行一次处理：1234567891011121314151617//js$(&apos;#upload&apos;).on(&apos;change&apos;, function()&#123; $.ajaxFileUpload(&#123; url: &apos;xxx/xx/xx&apos;, type: &apos;post&apos;, secureuri: false, fileElementId: &apos;upload&apos;, success: function(data, status)&#123; var str = $(data).find(&quot;body&quot;).text(); //获取返回的字符串 var json = $.parseJSON(str); //把字符串转化成json对象 console.log(json); //我们需要的数据 &#125;, error: function(data, status, e)&#123; &#125; &#125;);&#125;); 虽然我也不造具体什么原因，反正这样写就没得问题啦，先解决燃眉之急，再追究其所以然。 问题三：onchange上面问题都解决以后可以上传图片并获得图片id了，但是只能上传一张图片，再点击上传一张就不行了，网上查了资料说是ajaxFileUpload插件，它会把原来的file元素替换成新的file元素，所以之前绑定在旧的input上的change事件就失效了，需要重新绑定一次，试了一下果然有效，不过代码需要重新编排一下：12345678910111213141516171819202122232425262728293031323334$(&apos;#upload&apos;).on(&apos;change&apos;, upload);function upload()&#123; if(true)&#123; //根据需求相关操作 ajaxFileUpload(); &#125;else if(ddd)&#123; &#125;else &#123; &#125;&#125;function ajaxFileUpload()&#123; $.ajaxFileUpload(&#123; url: &apos;xxx/xx/xx&apos;, type: &apos;post&apos;, secureuri: false, fileElementId: &apos;upload&apos;, success: function(data, status)&#123; var str = $(data).find(&quot;body&quot;).text(); var json = $.parseJSON(str); // idList是需要提交给后台的用来放置图片id的数组 idList.push(json.result[0].id); &#125;, complete: function(xmlHttpRequest)&#123; $(&quot;#upload&quot;).replaceWith(&apos;&lt;input type=&quot;file&quot; id=&quot;upload&quot; name=&quot;file&quot; class=&quot;hidden&quot;&gt;&apos;); $(&quot;#upload&quot;).on(&quot;change&quot;, upload); &#125;, error: function(data, status, e)&#123; //error &#125; &#125;);&#125; 现在，照片上传没问题了，再把需要提交的表单数据提交给后台就👌了。 获取图片大小上传图片往往需要对用户上传图片大小进行限制，这里插入一段上传图片点击确定获取图片大小的方法：12345678910111213141516171819202122232425&lt;html&gt;&lt;head&gt; &lt;title&gt;获取图片大小&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;upload&quot; onchange=&quot;getSize()&quot;&gt; &lt;script src=&quot;js/jquery-2.1.4.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var size = 0; function getSize()&#123; //js原生方法 var file = document.getElementById(&quot;upload&quot;); size = file.files[0].size; var mSize = (size/1048576).toFixed(2); //单位是兆M console.log(mSize); //jQuery方法 //size = $(&quot;#upload&quot;)[0].files[0].size; //var mSize = (size/1048576).toFixed(2); //console.log(mSize); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 类型为file的input的样式这里既然说到这个type值是file的input标签，就来说下如何修改这种input的样式，一般默认的样式是很难看的，直接给input添加class样式修改又不起作用，所以就需要一点技巧。 方法一先把input按钮的透明度opacity设置为0，然后用a标签包裹该input，实现美化效果，这样美化后input的使用还是不变的：1234567891011121314151617181920212223242526272829303132333435363738394041&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;file input&lt;/title&gt; &lt;style&gt; .upload-a&#123; padding: 4px 10px; height: 20px; line-height: 20px; position: relative; cursor: pointer; color: #888; background-color: #fafafa; border: 1px solid #ddd; border-radius: 4px; overflow: hidden; display: inline-block; text-decoration: none; &#125; .upload-a input &#123; opacity: 0; position: absolute; font-size: 100px; right: 0; top: 0; cursor: pointer; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;upload-a&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;upload&quot;&gt;点击这里上传文件 &lt;/a&gt; &lt;script src=&quot;js/jquery-2.1.4.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(&apos;#upload&apos;).on(&apos;change&apos;, function()&#123; //选择成功以后执行的事件 &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 方法二这个方法a标签和input标签是同级的，只不过将input的display值设置了none，点击a标签的时候就触发input的click事件，再执行后面的操作：1234567891011121314151617181920212223242526272829303132333435363738&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;file input&lt;/title&gt; &lt;style&gt; .upload &#123; padding: 4px 10px; height: 20px; line-height: 20px; position: relative; cursor: pointer; color: #888; background-color: #fafafa; border: 1px solid #ddd; border-radius: 4px; overflow: hidden; display: inline-block; text-decoration: none; &#125; .hidden &#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a class=&quot;upload&quot;&gt;点击这里上传文件&lt;/a&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;upload&quot; class=&quot;hidden&quot;&gt; &lt;script src=&quot;js/jquery-2.1.4.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(&apos;.upload&apos;).on(&apos;click&apos;, function()&#123; $(&apos;#upload&apos;).click(); &#125;); $(&apos;#upload&apos;).on(&apos;change&apos;, function()&#123; //选择成功以后执行的事件 &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 第二种方法需要注意⚠️一个问题，这里的$(&#39;#upload&#39;)的change事件需要放在$(&#39;.upload&#39;)的click事件的外面。如果放在里面的话，那么每次触发click事件就会注册一个change事件监听器，这样的话，第一次点击上传会上传一张，第二次点击上传会上传两张（因为，第二次click以后就会注册两个change事件监听器），以此类推，每次点击都会增加一个监听器。🙏：感谢纪师傅","categories":[],"tags":[{"name":"-ajaxfileupload","slug":"ajaxfileupload","permalink":"http://yy709593266.github.io/blog/tags/ajaxfileupload/"}]},{"title":"Hello Vue!","slug":"20160708(helloVue)","date":"2016-07-08T09:28:26.000Z","updated":"2017-09-12T14:56:27.000Z","comments":true,"path":"2016/07/08/20160708(helloVue)/","link":"","permalink":"http://yy709593266.github.io/blog/2016/07/08/20160708(helloVue)/","excerpt":"其实看vue的教程我们知道，可以像使用jQuery一样来使用vue.js，即直接使用&lt;script&gt;&lt;/script&gt;标签加载进去就可以使用它了，这里主要讲的是使用npm安装vue的时候我遇到一些问题","text":"其实看vue的教程我们知道，可以像使用jQuery一样来使用vue.js，即直接使用&lt;script&gt;&lt;/script&gt;标签加载进去就可以使用它了，这里主要讲的是使用npm安装vue的时候我遇到一些问题 安装步骤1、首先保证你已经安装了node和npm2、打开Git，映射npm到cnpm$ npm install -g cnpm --registry=https://registry.npm.taobao.org(Mac下影射命令为$ sudo npm install -g cnpm --registry=https://registry.npm.taobao.org)3、安装vue-cli$ cnpm i -g vue-cli(Mac下命令为$ sudo cnpm i -g vue-cli)4、cd到一个你放置项目的文件夹，创建webpack项目并且下载依赖$ vue init webpack hellovue出现的选项可以直接点击enter跳过5、定位到项目中$ cd hellovue6、安装依赖模块$ cnpm i7、运行应用$ cnpm run dev现在可以在localhost:8080上查看我们的应用了。注：如果这时候需要使用npm安装其他的库，比如路由和XHR库的话，需要重新打开一个Git窗口 问题我运行的时候出现的是空白页，而且控制台报错了，说main.js文件中的import错误:12import Vue from &apos;vue&apos;import App from &apos;./App&apos; 这里我们需要使用require加载12var Vue = require(&apos;vue&apos;);var App = require(&apos;./App.vue&apos;); 这样就能正常运行第一个vue程序Hello World!了。后面就在里面添加内容或者文件就行了。","categories":[],"tags":[{"name":"-vue","slug":"vue","permalink":"http://yy709593266.github.io/blog/tags/vue/"}]},{"title":"从插件开发了解jQuery源码","slug":"20160623(jQuery-插件)","date":"2016-06-23T02:34:00.000Z","updated":"2016-11-10T02:13:03.000Z","comments":true,"path":"2016/06/23/20160623(jQuery-插件)/","link":"","permalink":"http://yy709593266.github.io/blog/2016/06/23/20160623(jQuery-插件)/","excerpt":"想要开发jQuery插件，首先必须了解并熟悉jQuery源码，了解它的整体架构以及方法的实现，这里主要对jQuery插件开发相关的方法并加上自己的理解来进行阐述jQuery源码相关知识，从而让你找到适合自己的方法去理解和开发一个jQuery插件。","text":"想要开发jQuery插件，首先必须了解并熟悉jQuery源码，了解它的整体架构以及方法的实现，这里主要对jQuery插件开发相关的方法并加上自己的理解来进行阐述jQuery源码相关知识，从而让你找到适合自己的方法去理解和开发一个jQuery插件。 jQuery的总体架构打开jQuery的源码，会发现这样的代码结构123(function (window, undefined) &#123; // jquery code&#125;)(window) 通过定义一个自调用的匿名函数，创建一个私有空间，该私有空间的变量和方法，不会破坏全局的命名空间。jQuery被应用在成千上万的JavaScript程序中，必须确保jQuery创建的变量不能和导入它的程序所使用的变量发生冲突。既然作用范围在这个匿名函数中，怎么被别人使用呢？1window.jQuery = window.$ = jQuery 这里让jQuery库中最重要的jQuery对象成为了window对象的一个属性，这样就可以在其他地方像使用window.document来使用jQuery对象了，而$是jQuery的同名对象 构造jQuery对象jQuery对象不是通过new jQuery创建的，而是通过new jQuery.fn.init创建的123456789var jQuery = function(selector, context)&#123; return new jQuery.fn.init(selector, context);&#125;jQuery.fn = jQuery.prototype = &#123; init: function(selector, context)&#123; //init的功能是对传进来的selector参数进行分析，进行各种不同的处理，然后生成jQuery对象 &#125; //...&#125; jQuery对象就是jQuery.fn.init对象，这样构造jQuery对象的方法，如果执行new jQuery()生成的jQuery对象会被抛弃，最后返回jQuery.fn.init对象，因此可以直接调用jQuery(selector, context)，没有必要使用new关键字。关于new出来的init和直接return的init有什么区别呢？如果是直接return的init的话12345678910111213var jQuery = function(selector, context) &#123; return jQuery.prototype.init();&#125;jQuery.prototype = &#123; init:function()&#123; this.age = 10; return this; &#125;, name:function()&#123; console.log(&apos;name&apos;); &#125;, age: 20&#125; 当执行jQuery()返回如下:jQuery()返回的是jQuery类的实例，init中的this其实也是指向jQuery类的实例。如果是new出来的init的话12345678910111213var jQuery = function(selector, context) &#123; return new jQuery.prototype.init();&#125;jQuery.prototype = &#123; init:function()&#123; this.age = 10 return this; &#125;, name:function()&#123; console.log(&apos;name&apos;); &#125;, age: 20&#125; 执行jQuery()返回如下：此时抛出错误，无法找到这个方法，所以显然就是new出来的init和jQuery类的this已经分离了。那么init想要访问到jQuery类原型上的属性和方法的话，实现的关键就是：123456789jQuery.fn = jQuery.prototype = &#123; init: function(selector, context)&#123; //init的功能是对传进来的selector参数进行分析，进行各种不同的处理，然后生成jQuery对象 &#125; //...&#125;jQuery.fn.init.prototype = jQuery.fn; // 通过原型传递解决，把jQuery原型传递给jQuery.prototype.init.prototype// 也就是jQuery的原型覆盖了init构造器的原型对象。 先执行jQuery.fn = jQuery.prototype，再执行jQuery.fn,init,prototype = jQuery.fn，合并后的代码就是jQuery.fn.init.prototype = jQuery.fn = jQuery.prototype。所有挂载到jQuery.fn的方法，相当于挂载到了jQuery.prototype，即挂载到了jQuery函数上，但是最后都相当于挂载到了jQuery.fn.init.prototype，相当于挂载到了一开始的jQuery函数返回的对象上，即挂载到了我们最终使用的jQuery对象上（因为我们一开始创建的jQuery对象就是jQuery函数返回的对象）。此时，执行jQuery()返回如下：每个函数都return this的话，就可以实现链式调用了，因为调用完一个方法以后返回对象依旧可以调用该对象上的其他方法。 jQuery插件接口方法jQuery.extend()和jQuery.fn.extend()常用于编写插件和处理函数的参数。1234jQuery.extend() 对jQuery本身的属性和方法进行了扩展//比如：$.ajax()、$.getJSON()方法等jQuery.fn.extend() 对jQuery.fn(即jQuery.prototype)的属性和方法进行了扩展//比如：$(ele).addClass()、$(ele).find()方法等 从jQuery源码中可以看到，jQuery.extend()方法和jQuery.fn.extend()方法其实是同指向同一方法的不同引用123jQuery.extend = jQuery.fn.jQuery = function () &#123; // ...&#125; 这两个方法指向同一个函数，怎么会实现不同的功能呢，这就是this的力量。jQuery.extend时，this指的是jQuery；jQuery.fn.extend时，this指的是jQuery.fn即jQuery.prototype。针对fn与jQuery其实是2个不同的对象： jQuery.extend调用的时候，this是指向jQuery对象的，所以这里扩展在jQuery上。把jQuery看成一个类的话，那么jQuery.extend就是在这个类上扩展了一个方法，直接$.functionname就可以直接用类来调用这个方法，即给jQuery类本身添加方法。 jQuery.fn.extend调用的时候，this指向fn对象，而jQuery.fn和jQuery.prototype指向同一对象，扩展fn就是扩展jQuery.prototype原型对象，就是类的实例化嘛，需要$(ele).functionname先实例化一个对象再来调用方法，即给jQuery对象添加方法。其实fn没有什么特别的意思，就只是jQuery.prototype的引用而已。 jQuery.extend的合并对象功能12jQuery.extend([deep], target, object1, [objectN])// 合并对象到第一个对象 第一种合并123456789101112var object1 = &#123; apple: 0, banana: &#123;weight: 52, price: 100&#125;, cherry: 97&#125;;var object2 = &#123; banana: &#123;price: 200&#125;, orange: 100&#125;;$.extend(object1, object2);// 将object1和object2合并到object1中了// object2值不变 第二种合并123456789101112var object1 = &#123; apple: 0, banana: &#123;weight: 52, price: 100&#125;, cherry: 97&#125;;var object2 = &#123; banana: &#123;price: 200&#125;, orange: 100&#125;;object3 = $.extend(&#123;&#125;,object1, object2);// 将object1和object2合并到object3上了// object1和object2值均不变 第三种–深度合并深度合并和非深度合并的区别是，深度合并的对象中如果复杂属性值(比如数组、函数、json对象等)，合并以后，如果再修改合子并对象的属性值，合并结果对象的值不会改变1234567891011121314var obj1 = &#123; a: &apos;a&apos;, b: &apos;b&apos;&#125;;var obj2 = &#123; c: &#123;cc: &apos;cc&apos;, ccc: &apos;ccc&apos;&#125;, d: &apos;d&apos;&#125;;$.extend(true, obj1, obj2);// 合并以后obj1和obj2都合并到obj1上了obj2.c.cc = &apos;11&apos;;//现在改变合并子对象obj2的属性值，合并后的obj1的属性值不会改变的console.log(obj2.c.cc); // 11console.log(obj1.c.cc); // cc","categories":[],"tags":[{"name":"-jQuery -插件","slug":"jQuery-插件","permalink":"http://yy709593266.github.io/blog/tags/jQuery-插件/"}]},{"title":"前端开发规范","slug":"20160617(前端开发规范)","date":"2016-06-17T07:55:43.000Z","updated":"2016-07-01T09:03:46.000Z","comments":true,"path":"2016/06/17/20160617(前端开发规范)/","link":"","permalink":"http://yy709593266.github.io/blog/2016/06/17/20160617(前端开发规范)/","excerpt":"为提高团队协作效率，便于后台人员添加功能及前端后期优化维护，特制订本文档。本文档如有不对或者不合适的地方请及时提出。","text":"为提高团队协作效率，便于后台人员添加功能及前端后期优化维护，特制订本文档。本文档如有不对或者不合适的地方请及时提出。 HTML编码原则第一行统一使用HTML5标准1234567&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;my title&lt;/title&gt; &lt;meta name=&quot;keywords&quot; content=&quot;xxxx, xxx, xxxxx&quot; /&gt; &lt;meta name=&quot;description&quot; content=&quot;xxxxxxxxxxxxxxxxxxxx&quot; /&gt; 语言类型12345678&lt;!-- 中文 --&gt;&lt;html lang=&quot;zh-Hans&quot;&gt;&lt;!-- 简体中文 --&gt;&lt;html lang=&quot;zh-cmn-Hans&quot;&gt;&lt;!-- 繁体中文 --&gt;&lt;html lang=&quot;zh-cmn-Hant&quot;&gt;&lt;!-- English --&gt;&lt;html lang=&quot;en&quot;&gt; meta的使用123456&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt; // 优先使用最新版本的IE 和 Chrome 内核&lt;meta chartset=&quot;utf-8&quot;&gt; // 网页显示字符集&lt;meta name=&quot;description&quot; content=&quot;这里填您网站的简介&quot;&gt; // 网站简介&lt;meta name=&quot;keywords&quot; content=&quot;关键字1,关键字2,关键字3,...&quot;&gt; // 搜索关键字&lt;link href=&quot;style/style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt; // 网页的CSS规范 &lt;title&gt;这里是网页标题&lt;title&gt; // 网页标题 html标签 自闭和标签无需闭合(例如：img input br hr等) 可选的闭合标签需闭合(例如：’li’ ‘body’) 尽量减少标签数量1234567&lt;img src=&quot;images/google.png&quot; alt=&quot;Google&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;title&quot;&gt;&lt;ul&gt; &lt;li&gt;Style&lt;/li&gt; &lt;li&gt;Guide&lt;/li&gt;&lt;/ul&gt; 网页制作字体 在设定字体样式时对于文字字号样式和行间距样式必须使用CSS样式表 在网页中中文应首选使用宋体，英文和数字首选verdana和arial两种字体。一般使用中文宋体的9pt和11pt或12px和14.7px，黑体字或者宋体字加粗时，一般选用11pt和14.7px的字号比较合适 为了最大程度的发挥浏览器自动排版的功能，在一段完整的文字中请尽量不要使用&lt;br&gt;来人工干预分段 网页中的空白应该尽量使用text-indent、padding、margin等以及透明的gif图片来实现 行距建议用百分比来定义，常用的两个行距值为120%和150% 网页制作链接 在浏览器中，我们点击空链接时，它会自动将当前页面重置到首端，从而影响用户正常的阅读内容，我们用代码javascript:void(null)代替原来的#标记 html文件命名 各子页命名的原则首先应该以栏目名的英文翻译取单一单词为名称。例如： 关于我们 \\aboutus信息反馈 \\feedback产品 \\product html所有标签、属性、值均使用小写字母，且属性的值前后使用双引号，属性之间使用一个英文空格隔开1&lt;input type=&quot;text&quot; value=&quot;info&quot;&gt; 属性书写顺序 id class name data-xxx src, for, type, href aria-xxx, role12345&lt;a id=&quot;...&quot; class=&quot;...&quot; data-modal=&quot;toggle&quot; href=&quot;###&quot;&gt;&lt;/a&gt;&lt;input class=&quot;form-control&quot; type=&quot;text&quot;&gt;&lt;img src=&quot;...&quot; alt=&quot;...&quot;&gt; 布尔值属性HTML5 规范中 disabled、checked、selected等属性不用设置值1234567&lt;input type=&quot;text&quot; disabled&gt;&lt;input type=&quot;checkbox&quot; value=&quot;1&quot; checked&gt;&lt;select&gt; &lt;option value=&quot;1&quot; selected&gt;1&lt;/option&gt;&lt;/select&gt; 标签嵌套必须合理正确，严禁在行内元素内嵌使用块级元素标签 常见的块级元素有 :div、p、table、td、tr、ul、ol、li、fieldset、legen、form、 blockquote、h1-h6、dl、dt、dd … 常见的行内元素有:span、a、strong、 b、em、i、s、u、site…常见错误示例： a标签、span标签内嵌套包含div、p等标签 在li标签、dt、dd、标签内直接包含div、h1-h6等块级元素在某些浏览器下也会出现兼容性问题，谨慎使用。 合理规划文档结构，去除不必要的&lt;div&gt;标签先分析布局，划分框架，然后规划结构，最后编写代码html标签语义化常见标签语义 &lt;p&gt;：段落&lt;h1&gt; &lt;h2&gt; &lt;h3&gt; …：标题&lt;ul&gt;：无序列表&lt;ol&gt;：有序列表&lt;blockquote&gt;：大段引用&lt;cite&gt;：一般引用&lt;b&gt;：为样式加粗而加粗&lt;strong&gt;：为强调内容而加粗&lt;i&gt;：为样式倾斜而倾斜&lt;em&gt;：为强调内容而倾斜code：代码标识abbr：缩写 代码缩进规范 html代码的层级缩进为一个tab 跨行标签的开始标签和结束标签必须上下对齐 值为空的元素定义应该单独占用一行 前景图片编码原则1&lt;img alt=&quot;图片说明&quot; src=&quot;logo_header.png&quot; /&gt; img标签必须闭合 所有图片必须添加alt属性值 图片的名称分为头尾两部分，用下划线隔开，头部分表示此图片的大类性质。例如：广告、标志、菜单、按钮等 放置在页面顶部的广告、装饰图案等长方形的图片取名：banner 标志性的图片取名为：logo 在页面上位置不固定并且带有链接的小图片我们取名为button 在页面上某一个位置连续出现，性质相同的链接栏目的图片我们取名为：menu 装饰用的图片我们取名：pic 不带链接表示标题的图片取名：title 鼠标感应效果图片命名规范为”图片名+_on/off”。例如：menu_on.gif menu_off.gif 代码注释 使用&lt;!----&gt;的方式添加注释 html文档中对于单独的模块或者超过50行的超长代码块做注释 转义字符 : &amp;nbsp &lt; : &amp;lt > : &amp;gt ￥ : &amp;yen “ : &amp;quot &amp; : &amp;amp © : &amp;copy ® : &amp;reg ‘ : &amp;#39 ™ : &amp;trade × : &amp;times ÷ : &amp;divide IE中HTML条件注释12345678&lt;!--[if IE 6]&gt; IE6 &lt;![endif]--&gt; &lt;!--[if IE 7]&gt; IE7 &lt;![endif]--&gt; &lt;!--[if lt IE 8]&gt; 小于IE8 &lt;![endif]--&gt; &lt;!--[if lte IE 8]&gt; 小于等于IE8 &lt;![endif]--&gt; &lt;!--[if gt IE 6]&gt; 大于IE6 &lt;![endif]--&gt; &lt;!--[if gte IE 6]&gt; 大于等于IE6 &lt;![endif]--&gt; &lt;!--[if !IE]&gt; 除IE外都可识别 &lt;![endif]--&gt; &lt;!--[if IE]&gt; 所有的IE可识别 &lt;![endif]--&gt; CSS编码原则外联方式1&lt;link rel=&quot;stylesheet&quot; href=&quot;css/common.css&quot;&gt; 注意 原则上，不允许在html上直接写样式 内外联方式的类型声明type=&quot;text/css&quot;都可以省略 link和style标签都应该放在head中 禁止在css文件内部采用@import方式引入其他css文件 如遇修改线上css文件内引用的背景图，需要在相应url后添加版本号，如：1background: url(images/sprite.png?v=20160616); id和class使用规范 class应以功能或内容命名，不以表现形式命名 class和id单词字母小写，多个单词组成时，采用中划线-分隔 使用唯一的id作为JavaScript hook，同时避免创建无样式信息的class id是唯一的并是父级的，class是可以重复的并是子级的，所以id仅使用在大的模块上，class可用在重复使用率高及字级中 规避class与id重名 命名规范 规则命名采用小写加中划线-的方式，不允许使用大写字母或下划线_ 命名推荐采用更简明有语义单词进行组合，应尽量避免使用中文拼音，尤其是首字母简拼 DOM一律不准使用id挂载css，且避免id和class重名 规则名称中不应该包含颜色(red/blue)、大小(width/height)等信息，应该使用其意义或功能命名，而不是样式显示结果 禁止类名中出现ad字样，防止被广告插件屏蔽 取父级元素id/class命名部分命名123&lt;div id=&quot;main&quot;&gt; &lt;div class=&quot;main_firstnav&quot;&gt;&lt;div&gt;&lt;/div&gt; 书写规范 禁止直接为html的tag添加css样式，如： 1div &#123;color: red;&#125; 尽量避免使用!important 如果可以，颜色尽量用三位字符表示 0后面不需要单位，0.8px可以略写成.8px 如果没有边框时，不要写成 1border: 0; 应该写成 1border: 0 none; background、font等可以缩写的属性，尽量使用缩写形式，合并margin、padding、border的值时，尽量使用缩写 规范属性书写顺序 显示、位置属性(Positioning)display, position, left, top, float, clear, list-style 自身属性(Box model)width, height, margin, padding, border 背景、行高(Typographic)background, line-height 文本属性(Visual)color, font, text-decroration, text-align, white-space, vertical-align, word-wrap, word-break 其他(Other)cursor, z-index, zoom, opacity css3transform, transition, animation, box-shadow, border-radius hack12345678910111213141516171819202122232425262728293031323334.declaration-order &#123; /* Positioning */ position: absolute; top: 0; right: 0; bottom: 0; left: 0; z-index: 100; /* Box model */ display: block; box-sizing: border-box; width: 100px; height: 100px; padding: 10px; border: 1px solid #e5e5e5; border-radius: 3px; margin: 10px; float: right; overflow: hidden; /* Typographic */ font: normal 13px &quot;Helvetica Neue&quot;, sans-serif; line-height: 1.5; text-align: center; /* Visual */ background-color: #f5f5f5; color: #fff; opacity: .8; /* Other */ cursor: pointer;&#125; 排版规范单行书写 多个selector共用一个样式集时，多个selector之间作为分隔标识的逗号后需要一个空格 每一个规则的大括号{前后都添加一个空格 属性名与值得冒号前不加空格，冒号之后加空格 每一个属性值后必须添加分号，并且分号后空格1selector, selector2, selector3 &#123; display: block; width: 100px; border: 1px solid #F00; &#125; 多行书写 多个selector共用一个样式集时，多个selector单独成行 每一个规则的大括号{前添加空格 属性名与值得冒号前不加空格，冒号之后加空格 每一个属性值后必须添加分号1234567selector,selector2,selector3 &#123; dispaly: block; width: 100px; border: 1px solid #F00;&#125; 链接的样式顺序a:link-&gt;a:visited-&gt;a:hover-&gt;a:active 正确使用display属性display属性会影响页面的渲染，请合理使用 display: inline后不应该再使用 width、height、margin、padding以及float； display: inline-block后不应该再使用float； display: block后不应该再使用vertical-align； display: table-*后不应该再使用margin或者float； 不要使用@import与&lt;link&gt;相比，@import要慢很多，不光增加额外的请求数，还会导致不可预料的问题，替代办法： 使用多个元素； 通过Sass或Less类似的CSS预处理器将多个CSS文件编译为一个文件 其他CSS文件合并工具 媒体查询将媒体查询放在尽可能相关规则的附近。不要将他们打包放在一个单一样式文件中或者放在文档底部。如果你把他们分开了，将来只会被大家遗忘123456789.element &#123; ... &#125;.element-avatar &#123; ... &#125;.element-selected &#123; ... &#125;@media (max-width: 768px) &#123; .element &#123; ...&#125; .element-avatar &#123; ... &#125; .element-selected &#123; ... &#125;&#125; 其他 在可以不使用引号的情况下尽量不使用引号 使用单引号，不建议使用双引号 开发阶段的css 文件（非单条样式集），为了能够对开发人员友好，不要求压缩为单行。发布生产的css 文件，外联文件或内联片段都需要压缩为单行，且删除注释与非属性值内空格。 性能优化 选择器应该在满足功能的基础上尽量简洁，减少嵌套选择器的查询消耗 在保持代码解耦的前提下，尽量合并重复的样式，例如： 12h1&#123;color:red;&#125;p&#123;color:red;&#125; 应该写成 1color,p&#123;color:red&#125; css背景图要使用sprite技术，可按照相关度（是否模块、页面等）进行合并，并存储为web所用格式。图片优先使用png8格式保存，并适当压缩体积。在存在透明通道的情况下可使用png24图片，在色值较多的情况下，可使用jpg格式保存 充分利用html自身属性及样式继承原理减少代码量。例如 123&lt;ul&gt; &lt;li&gt;这里是标题&lt;span&gt;2016-8-7&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt; 中定义 12345ul li&#123; position: relative; &#125;ul li span&#123; position: absolute; right: 0;&#125; 即可实现日期居右显示 提升CSS选择器性能CSS 选择器对性能的影响源于浏览器匹配选择器和文档元素时所消耗的时间，所以优化选择器的原则是应尽量避免使用消耗更多匹配时间的选择器。而在这之前我们需要了解CSS选择器匹配的机制，如子选择器规则：1#header &gt; a &#123;font-weight:blod;&#125; CSS选择器是从右到左进行规则匹配。了解这个机制后，例子中看似高效的选择器在实际中的匹配开销是很高的，浏览器必须遍历页面中所有的a元素并且确定其父元素的id是否为header。如果把例子的子选择器改为后代选择器则会开销更多，在遍历页面中所有a元素后还需向其上级遍历直到根节点1#header a &#123; font-weight: bold;&#125; 理解了CSS选择器从右到左匹配的机制后，明白只要当前选择符的左边还有其他选择符，样式系统就会继续向左移动，直到找到和规则匹配的选择符，或者因为不匹配而退出 避免使用通用选择器 1.content * &#123; color: red; &#125; 浏览器匹配文档中所有的元素后分别向上逐级匹配class为content的元素，直到文档的根节点。因此其匹配开销是非常大的，所以应避免使用关键选择器是通配选择器的情况 避免使用标签或class选择器限制id选择器 1234/* Not recommended */button#backButton &#123;…&#125;/* Recommended */#newMenuIcon &#123;…&#125; 避免使用标签限制class选择器 1234/* Not recommended */treecell.indented &#123;…&#125;/* Recommended */.treecell-indented &#123;…&#125; 避免使用多层标签选择器，使用class选择器替换，减少css查找 1234/* Not recommended */treeitem[mailfolder=&quot;true&quot;] &gt; treerow &gt; treecell &#123;…&#125;/* Recommended */.treecell-mailfolder &#123;…&#125; 避免使用子选择器 123456/* Not recommended */treehead treerow treecell &#123;…&#125;/* Recommended */treehead &gt; treerow &gt; treecell &#123;…&#125;/* Much to recommended */.treecell-header &#123;…&#125; 使用继承 1234/* Not recommended */#bookmarkMenuItem &gt; .menu-left &#123; list-style-image: url(blah) &#125;/* Recommended */#bookmarkMenuItem &#123; list-style-image: url(blah) &#125; 常用的CSS命名规则页面结构 容器: container页头：header内容：content/container页面主体：main页尾：footer导航：nav侧栏：sidebar栏目：column页面外围控制整体佈局宽度：wrapper左右中：left right center 导航 导航：nav主导航：mainnav子导航：subnav顶导航：topnav边导航：sidebar左导航：leftsidebar右导航：rightsidebar菜单：menu子菜单：submenu标题: title摘要: summary 功能 标志：logo广告：banner登陆：login登录条：loginbar注册：register搜索：search功能区：shop标题：title加入：joinus状态：status按钮：btn滚动：scroll标籤页：tab文章列表：list提示信息：msg当前的: current小技巧：tips图标: icon注释：note指南：guild服务：service热点：hot新闻：news下载：download投票：vote合作伙伴：partner友情链接：link版权：copyright JavaScript编码规范变量声明 命名要有意义，可读性强 声明变量必须加上var关键字，严格控制作用域 私有变量名用下划线_开头 参数大于3个时，应以对象形式作为参数集传递 一般变量名用下划线分隔方式或者驼峰方式 驼峰方式命名的变量第一个字母小写，剩下的每个有意义的单词的首字母大写 12var class_name = &quot;sunny&quot;;var className = &quot;sunny&quot;; 常量必须使用大写字符，并用下划线分隔 1var ID_USER; 构造函数必须使用首字大写 123function Class()&#123; &#125; boolean类型的变量使用is或has开头 12var is Ready = false;var hasMoreCommands = false; 书写规范 即使只有一条语句也最好不要省略{} 123if (boolean) &#123; return;&#125; 使用{}代替new Object()，使用[]代替new Array() 1var arr = [], obj = &#123;&#125;; 每个语句结束必须使用分号 尽量不要让每行超过120字符超长的不可分割的代码例外，比如复杂的正则表达式运算符处换行时，运算符必须在新行的行首1234567if (user.isAuthenticated() &amp;&amp; user.isInRole(&apos;admin&apos;) &amp;&amp; user.hasAuthority(&apos;add-admin&apos;) || user.hasAuthority(&apos;delete-admin&apos;))&#123; // code&#125; 接口命名规范 可读性强，见名晓义 尽量不与jQuery社区已有的习惯冲突 尽量写全，不用缩写，除非是下面列表中约定的： options：表示选项，与 jQuery 社区保持一致，不要用 config, opts 等active：表示当前，不要用 current 等index：表示索引，不要用 idx 等trigger：触点元素triggerType：表示触发类型、方式context：表示传入的 this 对象object：推荐写全，不推荐简写为 o, obj 等element：推荐写全，不推荐简写为 el, elem 等length：不要写成 len, lprev：previous 的缩写next：next 下一个constructor：不能写成 ctoreasing：示动画平滑函数min：minimize 的缩写max：maximize 的缩写DOM：不要写成 dom, Dom.hbs：使用 hbs 后缀表示模版btn：button 的缩写link：超链接title：主要文本img：图片路径（img标签src属性）dataset：html5 data-xxx 数据接口theme：主题className：类名classNameSpace：class 命名空间 空格、缩进、空行 语句中的必要空格和缩进，缩进的单位为四个空格 =前后需要跟空格，建议数值操作符(如：+/-/*/%)两边留空 1var name = &quot;Tom&quot;; for循环条件中，分号后留一空格 123for( var i = 0; i &lt; 10; i++)&#123; // dosomething&#125; 变量声明语句，数组值，对象值及函数参数中的逗号后留一空格 1234var a = 0, b = 1, c = 2;var arr = [1, 2, 3];var obj = &#123;a: 1, b: 2, c: 3&#125;;function(a, b, c)&#123;&#125; 空行不要有空格，行尾不要有空格 逗号和冒号后一定要跟空格，点号前后不要出现空格 空对象和数组不要填入空格 不要吝啬空行，尽量使用空行将逻辑相关的代码块分割开，以提高程序的可读性 合理的格式化和缩进1234567891011121314151617181920212223var obj = &#123; getName: &quot;1&quot;, setName: &quot;0&quot;&#125;if (success) &#123; doSomething(1);&#125; else if (fail) &#123; doSomething(2);&#125; else &#123; doSomething(3);&#125;switch (variable) &#123; case &apos;1&apos;: // do... break; case &apos;2&apos;: // do... break; default: // do...&#125; 类型转换 建议转换成string时，使用+ &#39;&#39; 1234567// goodnum + &apos;&apos;;// badnew String(num);num.toString();String(num); 建议转换成number时，使用+ 12345// good+str;// badNumber(str); 使用parseInt时，建议加上进制 1parseInt(&quot;1&quot;, 10); True和False布尔值 下列值在布尔表达式中结果为false nullundefined‘’ // 空字符串0 //数字 而下面的为true ‘0’ // 字符串[] //空数组{} // 空对象 还有一些难以区分的表达式，以下表达式结果为true123456789101112131415161718192021Boolean(&apos;0&apos;) == true&apos;0&apos; != true0 != null0 == []0 == falseBoolean(null) == falsenull != truenull != falseBoolean(undefined) == falseundefined != trueundefined != falseBoolean([]) == true[] != true[] == falseBoolean(&#123;&#125;) == true&#123;&#125; != true&#123;&#125; != false 不要在Array上使用for infor-in循环只用于object/map/hash的遍历，对Array用for-in循环有时会出错，因为它不是从0到length - 1进行遍历，而是所有出现在对象及其原型链的键值12345678910111213141516171819202122// Not recommendedfunction printArray(arr) &#123; for (var key in arr) &#123; print(arr[key]); &#125;&#125;printArray([0,1,2,3]); // This works.var a = new Array(10);printArray(a); // This is wrong.a = document.getElementsByTagName(&apos;*&apos;);printArray(a); // This is wrong.// Recommendedfunction printArray(arr) &#123; var l = arr.length; for (var i = 0; i &lt; l; i++) &#123; print(arr[i]); &#125;&#125; 二元和三元操作符操作符始终写在前一行12345678var x = a ? b : c;var y = a ? longButSimpleOperandB : longButSimpleOperandC;var z = a ? moreComplicatedB : moreComplicatedC; 条件操作符三元操作符用于替代if条件判断语句123456789// Not recommendedif (val != 0) &#123; return foo();&#125; else &#123; return bar();&#125;// Recommendedreturn val ? foo() : bar(); &amp;&amp;和||二元布尔操作符是可短路的，只有在必要时才会计算到最后一项123456789101112131415// Not recommendedfunction foo(opt_win) &#123; var win; if (opt_win) &#123; win = opt_win; &#125; else &#123; win = window; &#125; // ...&#125;// Recommendedfunction foo(opt_win) &#123; var win = opt_win || window; // ...&#125; 12345678910111213// Not recommendedif (node) &#123; if (node.kids) &#123; if (node.kids[index]) &#123; foo(node.kids[index]); &#125; &#125;&#125;// Recommendedvar kid = node &amp;&amp; node.kids &amp;&amp; node.kids[index];if (kid) &#123; foo(kid);&#125; jQuery规范建议使用最新版本的jQuery，版本越新，性能越好 jQuery变量 存放jQuery对象的变量以$开头 将jQuery选择器返回的对象缓存到本地变量中复用 使用驼峰式命名变量12var $myDiv = $(&quot;#myDiv&quot;);$myDiv.click(function()&#123;...&#125;); jQuery选择器 尽可能的使用 ID 选择器，因为它会调用浏览器原生方法document.getElementById查找元素。当然直接使用原生document.getElementById方法性能会更好 在父元素中选择子元素使用.find()方法性能会更好，因为ID选择器没有使用到Sizzle选择器引擎来查找元素12345// Not recommendedvar $productIds = $(&quot;#products .class&quot;);// Recommendedvar $productIds = $(&quot;#products&quot;).find(&quot;.class&quot;); DOM操作 当要操作DOM元素的时候，尽量将其分离节点，操作结束后，再插入节点 使用字符串连接使用array.join要比.append()性能更好1234567891011121314151617181920// Not recommendedvar $myList = $(&quot;#list&quot;);for(var i = 0; i &lt; 10000; i++)&#123; $myList.append(&quot;&lt;li&gt;&quot;+i+&quot;&lt;/li&gt;&quot;);&#125;// Recommendedvar $myList = $(&quot;#list&quot;);var list = &quot;&quot;;for(var i = 0; i &lt; 10000; i++)&#123; list += &quot;&lt;li&gt;&quot;+i+&quot;&lt;/li&gt;&quot;;&#125;$myList.html(list);// Much to recommendedvar array = [];for(var i = 0; i &lt; 10000; i++)&#123; array[i] = &quot;&lt;li&gt;&quot;+i+&quot;&lt;/li&gt;&quot;;&#125;$myList.html(array.join(&apos;&apos;)); 事件 如果需要，对事件使用自定义的namespace，这样容易解绑特定的事件，而不会影响到此DOM元素的其他事件监听 对Ajax加载的DOM元素绑定事件时尽量使用事件委托，事件委托允许在父元素绑定事件，子代元素可以响应事件，也包括Ajax加载后添加的子代元素12345// Not recommended$(&quot;#list a&quot;).on(&quot;click&quot;, myClickHandler);// Recommended$(&quot;#list&quot;).on(&quot;click&quot;, &quot;a&quot;, myClickHandler); 链式写法 尽量使用链式写法而不是用变量缓存或者多次调用选择器的方法 当链式写法超过三次或者因为事件绑定变得复杂后，使用换行和缩进保持代码可读性123456$(&quot;#myDiv&quot;).addClass(&quot;error&quot;).show();$(&quot;#myLink&quot;) .addClass(&quot;bold&quot;) .on(&quot;click&quot;, myClickHandler) .on(&quot;mouseover&quot;, myMouseOverHandler) .show(); 性能优化避免不必要的DOM操作浏览器遍历 DOM 元素的代价是昂贵的。最简单优化DOM树查询的方案是，当一个元素出现多次时，将它保存在一个变量中，就避免多次查询 DOM 树了12345678910111213// Not recommendedfor (var i = 0; i &lt; 100; i++) &#123; document.getElementById(&quot;myList&quot;).innerHTML += &quot;&lt;span&gt;&quot; + i + &quot;&lt;/span&gt;&quot;;&#125;// Recommendedvar myList = &quot;&quot;;var myListHTML = document.getElementById(&quot;myList&quot;).innerHTML;for (var i = 0; i &lt; 100; i++) &#123; myList += &quot;&lt;span&gt;&quot; + i + &quot;&lt;/span&gt;&quot;;&#125;myListHTML = myList; 缓存数组长度循环无疑是和JavaScript性能非常相关的一部分，通过存储数组的长度，可以有效避免每次循环重新计算1234567891011var arr = new Array(1000), len, i;// Recommended - size is calculated only 1 time and then storedfor (i = 0, len = arr.length; i &lt; len; i++) &#123;&#125;// Not recommended - size needs to be recalculated 1000 timesfor (i = 0; i &lt; arr.length; i++) &#123;&#125; 异步加载第三方内容当你无法保证嵌入第三发内容可以正常工作的时候，你需要考虑用异步加载这些代码，以免阻塞整个页面加载1234567891011121314151617(function() &#123; var script, scripts = document.getElementsByTagName(&apos;script&apos;)[0]; function load(url) &#123; script = document.createElement(&apos;script&apos;); script.async = true; script.src = url; scripts.parentNode.insertBefore(script, scripts); &#125; load(&apos;//apis.google.com/js/plusone.js&apos;); load(&apos;//platform.twitter.com/widgets.js&apos;); load(&apos;//s.widgetsite.com/widget.js&apos;);&#125;()); 避免使用jQuery实现动画 禁止使用slideUp/Down() fadeIn/Out()等方法 尽量不使用animate()方法 注释 如无必要，勿增注释 如有必要，尽量详尽 单行注释12//名称var name = 0; 多行注释使用多个单行注释 123// code// code// code 函数/方法注释1234567891011121314151617/** * 函数描述 * * @param &#123;string&#125; p1 参数1的说明 * @param &#123;string&#125; p2 参数2的说明，比较长 * 那就换行了. * @param &#123;number=&#125; p3 参数3的说明（可选） * @return &#123;Object&#125; 返回值描述 */function foo(p1, p2, p3) &#123; var p3 = p3 || 10; return &#123; p1: p1, p2: p2, p3: p3 &#125;;&#125; sublime中安装DocBlock插件，方便注释编写","categories":[],"tags":[{"name":"-前端开发规范","slug":"前端开发规范","permalink":"http://yy709593266.github.io/blog/tags/前端开发规范/"}]},{"title":"HEXO搭建个人博客","slug":"20160611-start","date":"2016-06-11T08:09:43.000Z","updated":"2017-05-08T09:26:00.000Z","comments":true,"path":"2016/06/11/20160611-start/","link":"","permalink":"http://yy709593266.github.io/blog/2016/06/11/20160611-start/","excerpt":"第一次使用hexo搭建个人博客，记录下搭建全过程。","text":"第一次使用hexo搭建个人博客，记录下搭建全过程。 1、github上新建仓库blog； 2、安装hexo首先要安装node环境，以及git1$ npm install hexo -g 3、新建本地博客文件夹hexo init filename1$ hexo init &apos;blog&apos; 生成的文件夹中的source文件夹用来存放博客正文内容 source 4、创建新博客(文章)找到source文件夹，在该文件夹下的_posts文件夹下创建博客名为start的博客1$ hexo new &apos;start&apos; 5、更换主题(可选)：github上clone下nexT主题1git clone nexT&apos;url 注意将主题clone到theme文件夹中； 6、主题配置: http://theme-next.iissnan.com/包括：标签页，分类，关于等… 7、站点配置中添加1theme: next 8、发布本地博客预览hexo cleanhexo g：generator将md文件转换成html文件hexo server: 启动本地服务浏览器中输入localhost:4000预览 9、发布远程博客配置(这是我的)站点配置文件中添加配置文件1234deploy: type: git repository: https://github.com/yy709593266/yy709593266.github.io.git branch: master 10、发布1hexo deploy 11、访问个人博客网站：http://yy709593266.github.io/ 附：具体操作参考文档hexo中文文档 🙏：感谢大神对我的支持和帮助。棒棒哒。。。哈哈哈","categories":[],"tags":[{"name":"-hexo -博客 -github","slug":"hexo-博客-github","permalink":"http://yy709593266.github.io/blog/tags/hexo-博客-github/"}]}]}